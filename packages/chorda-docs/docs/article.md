# Статья

Пришла осень и созрела очередная версия фреймворка Chorda. Теперь 3.0.

Про сам фреймворк можно почитать [здесь](https://chorda-docs.netlify.app), посмотреть [здесь](https://chorda-demo.netlify.app/#/elements/box) и пощупать [тут](https://github.com/eliace/chorda3)

В [прошлый раз](https://habr.com/ru/post/522162/) я рассказывал о дизайн-функции, чертежах и построении API компонентов, а в этот раз попробую заинтересовать вас некоторыми очевидными решениями и неочевидными следствиями, которые появились при работе с Chorda

## Очевидные решения

Есть ряд вещей, которые меня не устраивали, когда я работал с другими библиотеками и фреймворками. Всегда казалось, что можно сделать лучше

### Расширение библиотечных компонентов

Начну с декларативного подхода и примесей. Здесь для наглядности понадобится немного кода

Создадим простой компонент на JSX с кнопкой и текстом. Задача: при клике по кнопке меняется текст

```jsx
const MyComponent = () => {

    const [data, changeData] = useState('')

    const hahdleClick = (e) => {
        changeData('Hello')
    }

    return <div>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// вот так выглядит применение компонента
<MyComponent/>
```

Сделаем похожий функционал, используя чертеж Chorda

```javascript
// вырожденная дизайн-функция
const MyComponent = () => {
    return {
        templates: {
            button: {
                tag: 'button',
                text: 'Click me',
                events: {
                    // обработка событий VDOM
                    $dom: {
                        click: (evt, {data}) => {
                            data.$value = 'Hello'
                        }
                    }
                }
            },
            text: {
                tag: 'p',
                reactions: {
                    // реакции компонента на изменение переменной скоупа
                    data: v => patch({text: v})
                }
            }
        },
        initials: {
            // инициализация переменной в скоупе
            data: () => observable('')
        }
    }
}

// создаем чертеж
MyComponent()
```

Ой, все. Расходимся, ребята. Очевидно же, что шаблонный синтаксис намного проще и понятнее.

Но

Давайте пойдем немножко дальше. Вот мы передаем наш новый JSX компонент коллеге, скажем, в составе корпоративной или публичной библиотеки, а потом от того приходит просьба: хочу, чтобы компонент можно было стилизовать. Не вопрос. Самый простой и быстрый способ это сделать - дать возможность управлять классом корневого компонента через пропсы. 

Поехали

```jsx
// Придется залезть в библиотеку (!) и сделать пару правок

const MyComponent = (props) => {

    const {rootClassName} = props

    /* Тут ничего не меняется. Пропускаем */

    return <div className={rootClassName}>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// рендерим
<MyComponent rootClassName="custom" />
```

Тем временем в Chorda

```javascript
// Менять оригинальный чертеж необходимости нет

// В месте применения создадим примесь
mix(MyComponent(), {
    css: 'custom',
})
```

Естественно, стилизацией дело не заканчивается. Чем дальше, тем больше хотелок и тем больше пропсов нам понадобится добавить.

На самом деле подобные извращения следует пресекать в зародыше и сразу предоставлять возможность потребителю "слотировать" вложенные компоненты. Однако, в нашем примере компоненты жестко связаны state-параметром **data**, просто так вытащить их не получится, поэтому посмотрим, во что может превратиться реализация с пропсами

```javascript
const MyComponent = (props) => {

    const {rootProps, buttonProps, text: MyText} = props

    /* тут ничего не меняется */

    return <div {...rootProps} >
        <button onClick={handleClick} {...buttonProps} >Click me</button>
        <MyText>{data}</MyText>
    </div>
}

<MyComponent 
    rootProps={{className: 'custom'}} 
    buttonProps={{className: 'custom-button'}}
    text={props => <p className="custom-text">{props.children}</p>}
    />

```

В ситуации с чертежом без особых именений. Продолжаем смешивать

```javascript
// Расширяем примесь

mix(MyComponent(), {
    css: 'custom',
    templates: {
        button: {
            css: 'custom-button'
        },
        text: {
            css: 'custom-text'
        }
    }
})
```

Для React типовое решение проблемы это вынесение состояния из компонента. Получившийся "глупый" компонент уже не будет иметь внутри сильной связи и позволит легко "слотировать" вложения. Но здесь есть подводный камень. Архитектура такая штука, что если где-то убыло, то где-то прибыло. Выбрасывая сложность из наших компонентов мы ее копим в другом месте, а именно там, где компонент будет применяться

Стоит признать, что и с примесями тоже не все так гладко. Чтобы сделать хорошо расширяемый компонент, его необходимо сильно декомпозировать, а это напрямую влияет на производительность и восприятие кода в целом (по второму пункту полезно почитать о причинах появления setup во Vue 3)

Так к чему все это сравнение? Тот же React может предложить много вариантов и подходов для расширения функционала, один экзотичнее другого. Chorda предлагает один путь (на самом деле нет), что на мой взгляд экономит на выборе уйму времени

### Этот компонент мне не подходит

Идем дальше. Мы рассмотрели как именно выполняются изменения отдельного компонента, но что если вы являетесь не автором библиотеки компонентов, а ее потребителем и столкнулись с проблемой нехватки функционала? 

Тогда на выбор:
1. Делаем форк, вносим в него правки. Делаем PR в репо библиотеки. Пока ждем влития, пользуемся форком
2. Делаем свой компонент. Используем его вместо библиотечного. Ждем новой версии библиотеки
3. (для обладателей особого дара убеждения) Объясняем автору библиотеки в чем *он* не прав и почему *он* должен внести нужные *вам* правки как можно скорее. Профит!
4. Забиваем

Если вы используете Chorda, то у вас появляется еще один вариант: подмешать свой функционал к чужому компоненту. В этом случае компонент как-бы продолжает оставаться частью оригинальной библиотеки, но не конфликтуя с ней

### Mount или не Mount?

Наверно, правильнее этот вопрос должен звучать так: в какой момент должна начинаться обработка бизнес задач? 

Хорошо проиллюстрирует мою мысль пример с загрузкой данных в store нашего приложении при открытии страницы. Как правило, загрузка выполняется по событию монтирования VDOM узла, что есть странно - зачем что-то добавлять в DOM, если данных еще нет? Почему бы нам сначала не загрузить данные, а потом решать - рендерить что-то или нет. Тут ситуацию немного спасает Suspense и понятие асинхронных компонентов, когда у каждого компонента есть своя отложенная задача и, соответсвенно, отложенная отрисовка

Мне больше нравится вариант, когда загрузка вообще никак не связана с рендерингом. В Chorda бизнес-логика находится на уровне дерева компонентов, а результаты выполнения бизнес-задач влияют только на store/state, не касаясь отрисовки напрямую

### Все мы вместе и каждый сам по себе

В Chorda состояние компонента определяется только его скоупом (что-то вроде локального store/state), компонент видит только свой скоуп и работает только с ним, считая, что вокруг никого нет. Это позволяет спокойно выполнять смешивание, не опасаясь сломать жесткие связи между компонентами

По умолчанию, скоуп делит свое содержимое с другими связанными скоупами, таким образом позволяя компонентам иметь доступ, например, к общему роуту, но в то же время любой компонент может локально изменить свой скоуп так как ему нужно

Поскольку конвейер обработки (вычисление-патч-отрисовка) попадает к компонентам через скоуп как и любое другое значение, его тоже можно настроить локально. К примеру, стратегия базового конвейера дает построение дерева компонентов в ширину с удержанием задач отрисовки до окончания обработки всех патчей. Если для вашего компонента или блока компонентов такое решение не подходит, вы можете подключить к ним свой кастомный конвейер

## Неочевидные следствия

А вот некоторые вещи не являлись моей изначальной целью, но появились на пути развития фреймворка

### Встраивание в существующие проекты

Реализация виртуального DOM не входит в состав Chorda. Разработка еще одного нового рендерера не решала моих проблем, поэтому я планировал использовать один из уже существующих. Для того, чтобы попробовать Chorda в поле, я собрался переписать пару домашних проектов с нуля. Но приступив, почти сразу понял, что это не обязательно. Оказалось, что можно просто заменить отдельные компоненты, подключив правильный рендерер, и так потихоньку съесть слона по частям

Интересный вопрос: если фреймворк использует React, то можно ли сказать, что приложение, которое использует данный фреймворк, написано на React?

### Загружаем и работаем

Сомнительное следствие конечно, но для некоторых может оказаться чрезвычайно важным. Создание компонентов и отрисовка присходят в runtime, без этапа транспиляции. Подключив ядро Chorda и рендерер, можно сразу писать код, который тут же будет исполняться в браузере. 

Правда вот, SSR превратился в нетривиальную задачу

### Поведенческие компоненты

Тут скорее интересное наблюдение. Раньше я сталкивался только с таким подходом к "глупым" компонентам: есть простой компонент без логики работы, который знает как ему рисоваться, затем поверх него создается "умный" компонент, который включает сам "глупый" компонент и некоторое поведение. 

Так вот в Chorda (из-за того, что можно легко менять порядок смешивания) у меня появился набор компонентов, в которых есть только поведение (обычно набор стандартных реакций), без правил отрисовки. И получилось, что, наоборот, уже к поведению начинает примешиваться способ отображения в виде "глупых" компонентов

Как это может выглядеть:

```javascript
export default () => {
    // поведенческий компонент
    return Text({
        as: Paragraph, // "глупый" компонент
        text$: $ => $.user.name
    })
}
```

## Итог

Если фреймворк вас заинтересовал, или у вас есть предложения по его развитию - всегда пожалуйста.