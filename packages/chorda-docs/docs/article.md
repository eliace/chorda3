# Статья

Пришла осень и созрела очередная версия фреймворка Chorda. Теперь 3.0.

Про сам фреймворк можно почитать [здесь](docs), посмотреть [здесь](demo) и пощупать [тут](https://github.com/eliace/chorda3)

? В новой версии акцент смещен с компонентов на веб-приложение в целом и на стремление собрать вместе те подходы в разработке, которые показались мне наиболее удачными

В [прошлый раз](https://habr.com/ru/post/522162/) я рассказывал о дизайн-функции и чертежах, которые мне до сих пор кажутся удачной находкой, но в этот раз я попробую заинтересовать вас некоторыми очевидными решениями и неочевидными следствиями использования Chorda

## Очевидные решения

Есть ряд вещей, которые меня не устраивали при разработке с использованием существующих библиотек/фреймворков

### Расширение библиотечных компонентов

Начну с декларативного подхода и примесей. Здесь для наглядности понадобится немного кода

Рассмотрим пример с кнопкой и текстом, написанный на JSX. Задача: при клике по кнопке меняется текст

```jsx
const MyComponent = () => {

    const [data, changeData] = useState('')

    const hahdleClick = (e) => {
        changeData('Hello')
    }

    return <div>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// вот так выглядит применение компонента
<MyComponent/>
```

Сделаем похожий функционал, используя чертеж Chorda

```javascript
// вырожденная дизайн-функция
const MyComponent = () => {
    return {
        templates: {
            button: {
                tag: 'button',
                text: 'Click me',
                events: {
                    // обработка событий VDOM
                    $dom: {
                        click: (evt, {data}) => {
                            data.$value = 'Hello'
                        }
                    }
                }
            },
            text: {
                tag: 'p',
                reactions: {
                    // реакции компонента на изменение переменной скоупа
                    data: v => patch({text: v})
                }
            }
        },
        initials: {
            // инициализация переменной в скоупе
            data: () => observable('')
        }
    }
}

// создаем чертеж
MyComponent()
```

Все, ребята. Расходимся. Тут же все очевидно

Но

Давайте пойдем немножко дальше. Вот мы передаем наш новый JSX компонент коллеге, скажем, в составе корпоративной или публичной библиотеки, а потом от того приходит просьба: хочу, чтобы компонент можно было стилизовать. Наверно, самый простой способ это сделать - дать возможность управлять классом корневого компонента. 

*Можно усложнить задачу контролем классов всех вложенных компонентов, но для нашего примера это не так важно*

Поехали

```jsx
// Придется залезть в библиотеку (!) и сделать пару правок

const MyComponent = (props) => {

    const {rootClassName} = props

    /* Тут ничего не меняется. Пропускаем */

    return <div className={rootClassName}>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// рендерим
<MyComponent rootClassName="custom" />
```

Тем временем в Chorda

```javascript
// Менять оригинальный чертеж необходимости нет

// В месте применения создадим примесь
mix(MyComponent(), {
    css: 'custom',
})
```

Естественно, обычно стилизацией дело не заканчивается. Чем дальше, тем больше пропсов нам понадобится добавить.

На самом деле подобные извращения следует пресекать в зародыше и сразу давать возможность потребителю "слотировать" вложенные компоненты. Однако, в нашем примере компоненты жестко связаны state параметром **data**, просто так вытащить их не получится, поэтому посмотрим, во что может превратиться реализация с пропсами

```javascript
const MyComponent = (props) => {

    const {rootProps, buttonProps, text: MyText} = props

    /* тут ничего не меняется */

    return <div {...rootProps} >
        <button onClick={handleClick} {...buttonProps} >Click me</button>
        <MyText>{data}</MyText>
    </div>
}

<MyComponent 
    rootProps={{className: 'custom'}} 
    buttonProps={{className: 'custom-button'}}
    text={props => <p className="custom-text">{props.children}</p>}
    />

```

В работе с чертежом без особых именений. Продолжаем смешивать

```javascript
// Расширяем примесь

mix(MyComponent(), {
    css: 'custom',
    templates: {
        button: {
            css: 'custom-button'
        },
        text: {
            css: 'custom-text'
        }
    }
})
```

Для React типовое решение проблемы это вынесение состояния из компонента. Получившийся "глупый" компонент уже не будет иметь внутри сильной связи и позволит легко "слотировать" вложения. Но здесь есть подводный камень. Архитектура такая штука, что если где-то убыло, то где-то прибыло. Выбрасывая сложность из наших компонентов мы ее копим в другом месте, а именно там, где компонент будет применяться

Стоит признать, что и с примесями тоже не все так гладко. Чтобы сделать хорошо расширяемый компонент, его необходимо сильно декомпозировать, а это напрямую влияет на производительность и восприятие кода в целом (по второму пункту полезно почитать о причинах появления setup во Vue 3)

Так к чему все это сравнение? Тот же React может предложить много вариантов и подходов для расширения функционала, один экзотичнее другого. Chorda предлагает один путь (на самом деле нет), что на мой взгляд экономит на выборе уйму времени

### Этот компонент мне не подходит

Идем дальше. Мы рассмотрели как именно выполняются изменения отдельного компонента, но что если вы являетесь не автором библиотеки компонентов, а ее потребителем и столкнулись с проблемой нехватки функционала? 

Тогда на выбор:
1. Делаем форк, вносим в него правки. Делаем PR в репо библиотеки. Пока ждем влития, пользуемся форком
2. Делаем свой компонент. Используем его вместо библиотечного. Ждем новой версии библиотеки
3. (для обладателей особого дара убеждения) Объясняем автору библиотеки в чем *он* не прав и почему *он* должен внести нужные *вам* правки как можно скорее. Профит!
4. Забиваем

Смешивание позволяет добавить еще один вариант. Что-то среднее между 1 и 2. Вы создаете свой компонент, но он как-бы продолжает оставаться частью оригинальной библиотеки

### Mount или не Mount?

Наверно, правильнее этот вопрос должен звучать так: в какой момент должна начинаться обработка бизнес задач? 

Самое первое, с чем мы сталкиваемся, это загрузка данных в store нашего приложении. Как правило, загрузка выполняется по событию монтирования VDOM узла, что есть странно - зачем что-то рендерить, если данных еще нет? Ситуацию немного спасает Suspense и понятие асинхронных компонентов, когда у каждого компонента есть своя отложенная задача, и как только она будет выполнена, можно рендериться. Вроде и задача не выполнилась и DOM не создался

В Chorda логика работы находится на уровне компонентов приложения, т.е. бизнес задачи запускаются на этапе, когда создается структура приложения. 


### Все мы вместе и каждый сам по себе

В Chorda состояние компонента определяется только его скоупом, причем сам скоуп является открытым. Это обязательное требование для расширяемых компонентов, т.к. перекрыть или заменить закрытые переменные невозможно.

По умолчанию, скоуп один на всех, все компоненты имеют доступ например к общему роуту, но любой компонент может изменить скоуп для себя и своего поддерева

Стратегия базового конвейера Chorda дает построение дерева компонентов в ширину с удержанием задач отрисовки до окончания обработки всех патчей. Если для вашего приложения такое решение не подходит или вы хотите, к примеру, разделить приложение на блоки, которые отрисовываются независимо друг от друга, для каждого из них можно настроить свой собственный конвейер


## Неочевидные следствия

А вот некоторые вещи не являлись изначальной целью, но появились во время использования

### Встраивание в существующие проекты

Реализация VDOM не входит в состав Chorda. Разработка еще одного рендерера не решала моих проблем, поэтому предполагалось использовать один из уже существующих. Попробовав несколько вариантов, я дошел до ReactDOM. Для того, чтобы попробовать Chorda в деле, я собирался переписать пару проектов, но после некоторого шаманства выяснилось, что можно не переписывать, а продолжать работу в существующих проектах, постепенно заменяя компоненты и модули на Chorda

Была мысль сделать vdom-agnostic компонент и использовать одну и ту же библиотеку компонентов в проектах на разных vdom, но пока польза от этого не очевидна

Интересный вопрос: если фреймворк использует React, то можно ли сказать, что приложение, которое использует данный фреймворк, написано на React?

### Загружаем и работаем

Сомнительное следствие с моей точки зрения, но для некоторых это может оказаться важным. Создание страницы присходит в runtime, без этапа транспиляции. Подключив ядро и рендерер, мы готовые работы с компонентами. Правда, SSR в таком случае становится нетривиальной задачей

### Поведенческие компоненты

Можно взять "глупый" компонент и добавлять к нему поведение. А можно и наоборот, иметь компонент у которого есть только поведение, и уже к нему примешивать "глупые" компоненты

## Итог

Если фреймворк вас заинтересовал или у вас есть предложения по его развитию, всегда пожалуйста.