# Статья


## А в чем проблема?


## Очевидные плюшки

### Расширение библиотечных компонентов

Начну с самого сложного

Рассмотрим пример с кнопкой и текстом, написанный с помощью чертежа Chorda. При клике по кнопке меняется текст

```javascript
const MyComponent = () => {
    return {
        templates: {
            button: {
                tag: 'button',
                text: 'Click me',
                events: {
                    // обработка событий VDOM
                    $dom: {
                        click: (evt, {data}) => {
                            data.$value = 'Hello'
                        }
                    }
                }
            },
            text: {
                tag: 'p',
                reactions: {
                    // реакции компонента на изменение переменной скоупа
                    data: v => patch({text: v})
                }
            }
        },
        initials: {
            // инициализация переменной в скоупе
            data: () => observable('')
        }
    }
}

// создаем чертеж
const blueprint = MyComponent()
```

Сделаем похожий функционал, используя условную рендер-функцию и JSX

```jsx
const MyComponent = () => {

    const data = observable('')

    const hahdleClick = (e) => {
        data.$value = 'Hello'
    }

    return <div>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// вот так выглядит применение компонента
<MyComponent/>
```

Все, ребята. Расходимся. Тут же все очевидно

Но

Давайте немножко пофантазируем. Вот мы передаем JSX компонент коллеге в составе библиотеки. А потом от того приходит просьба: хочу компонент стилизовать. Простой и очевидный способ это сделать - дать возможность управлять классом корневого компонента. 

*Можно усложнить задачу контролем классов всех вложенных компонентов, но для нашнго примера это не так важно*

Поехали

```jsx
// Придется залезть в библиотеку и сделать пару правок

const MyComponent = (props) => {

    const {rootClassName} = props

    /* Тут ничего не меняется. Пропускаем */

    return <div className={rootClassName}>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// рендерим
<MyComponent rootClassName="custom" />
```

А тем временем в Chorda

```javascript
// Менять оригинальный чертеж необходимости нет

// В месте применения создадим примесь
const blueprint = mix(MyComponent, {
    css: 'custom',
})
```

Естественно, стилизацией дело не заканчивается. Чем дальше, тем больше пропсов нам будет нужно добавить.

На самом деле подобные извращения следует пресекать в зародыше и позволять потребителю "слотировать" вложенные компоненты. Однако, наши вложения жестко связаны приватной переменной `data`, просто так вытащить их не получится, поэтому посмотрим, во что может превратиться реализация с пропсами

```javascript
const MyComponent = (props) => {

    const {rootProps, buttonProps, text as MyText} = props

    /* тут ничего не меняется */

    return <div {...rootProps} >
        <button onClick={handleClick} {...buttonProps} >Click me</button>
        <MyText>{data}</MyText>
    </div>
}

<MyComponent 
    rootProps={{className: 'custom'}} 
    buttonProps={{className: 'custom-button'}}
    text={props => <p className="custom-text">{props.children}</p>}
    />

```

В Chorda без особых именений. Продолжаем смешивать

```javascript
// Расширяем примесь

const blueprint = mix(MyComponent, {
    css: 'custom',
    templates: {
        button: {
            css: 'custom-button'
        },
        text: {
            css: 'custom-text'
        }
    }
})
```

Для React типовым решением проблемы было бы вынесение состояния из компонента. Получившийся "глупый" компонент уже не будет иметь внутри сильной связи и позволит легко "слотировать" вложения. Но здесь есть подводный камень. Архитектура такая штука, что если где-то убыло, то где-то прибыло. Выбрасывая сложность из наших компонентов мы ее копим в другом месте, а именно там, где компонент будет применяться

Стоит признать, что и с примесями тоже не все так гладко. Чтобы сделать хорошо расширяемый компонент, его необходимо сильно декомпозировать, а это напрямую влияет на производительность и восприятие кода в целом (setup функция Vue не даст соврать)

Тут есть еще один момент. Мы рассмотрели как именно делается правка, но что если вы являетесь не автором библиотеки компонентов, а ее потребителем и столкнулись с проблемой нехватки функционала? 

Тогда на выбор:
1. Делаем fork, вносим в него правки. Делаем PR в репо библиотеки. Пока ждем влития, пользуемся форком
2. Делаем свой компонент. Используем его вместо библиотечного. Ждем новой версии библиотеки
3. (для обладателей особого дара убеждения) Объясняем автору библиотеки в чем *он* не прав и почему *он* должен внести нужные *вам* правки как можно скорее
4. Забиваем




### Mount или не Mount?

Наверно, правильнее задать вопрос так: в какой момент должна начинаться обработка бизнес задач? 

Самый распространенный пример это загрузка первичных данных на странице. Как правило, загрузка выполняется по событию монтирования VDOM узла, что не есть очевидно. Ситуацию немного спасает Suspense. Так, к примеру, Vue вводит понятие асинхронных компонентов и отложенной задачи рендеринга. Предполагается, что у каждого компонента своя задача, и как только она выполнена, можно рендериться

В Chorda логика работы собрана в точках подключения `joints`, т.к:

1. они не связаны с рендерингом, а только с инициализацией дерева компонентов

2. `joints` настраивают взаимосвязи между переменными скоупа, что как нельзя кстати в случае, если наши загружаемые данные захватывают несколько компонентов


### Каждый сам по себе

Состояние компонента определяется только его скоупом. Это обязательное требование для расширяемых компонентов, т.к. невозможно перекрыть или заменить приватные переменные.

Каждый компонент может иметь свой собственный изолированный движок (конвейер обработки). 


## Сомнительные плюшки

Появились во время использования. Не являлись изначальной целью.

### Встраивание в существующие проекты

Реализация VDOM не входит в состав Chorda. Разработка еще одного рендерера не решала моих проблем, поэтому предполагалось использовать один из уже существующих. Попробовав несколько вариантов, я дошел до ReactDOM. Для того, чтобы попробовать Chorda в деле, я собирался переписать пару проектов, но после некоторого шаманства выяснилось, что можно не переписывать, а продолжать работу в существующих проектах, постепенно заменяя компоненты и модули на Chorda

Была мысль сделать vdom-agnostic компонент и использовать одну и ту же библиотеку в проектах на разных фреймворках, но пока не вижу в этом большого смысла

### Тестирование бизнес-логики

Поскольку логика работы приложения в Chorda отвязана от отрисовки, ее можно проверить без реального рендеринга
