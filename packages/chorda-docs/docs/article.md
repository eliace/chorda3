# Статья

Пришла осень и созрела очередная версия фреймворка Chorda. Теперь 3.0.

Про сам фреймворк можно почитать [здесь](docs), посмотреть [здесь](demo) и пощупать [тут](https://github.com/eliace/chorda3)


## Очевидные решения

### Расширение библиотечных компонентов

Начну с декларативного подхода и примесей. 

Рассмотрим пример с кнопкой и текстом, написанный с помощью чертежа Chorda. При клике по кнопке меняется текст

```javascript
const MyComponent = () => {
    return {
        templates: {
            button: {
                tag: 'button',
                text: 'Click me',
                events: {
                    // обработка событий VDOM
                    $dom: {
                        click: (evt, {data}) => {
                            data.$value = 'Hello'
                        }
                    }
                }
            },
            text: {
                tag: 'p',
                reactions: {
                    // реакции компонента на изменение переменной скоупа
                    data: v => patch({text: v})
                }
            }
        },
        initials: {
            // инициализация переменной в скоупе
            data: () => observable('')
        }
    }
}

// создаем чертеж
const blueprint = MyComponent()
```

Сделаем похожий функционал, используя условную рендер-функцию и JSX

```jsx
const MyComponent = () => {

    const data = observable('')

    const hahdleClick = (e) => {
        data.$value = 'Hello'
    }

    return <div>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// вот так выглядит применение компонента
<MyComponent/>
```

Все, ребята. Расходимся. Тут же все очевидно

Но

Давайте пойдем немножко дальше. Вот мы передаем наш JSX компонент коллеге, например, в составе библиотеки, а потом от того приходит просьба: хочу, чтобы компонент можно было стилизовать. Простой и очевидный способ это сделать - дать возможность управлять классом корневого компонента. 

*Можно усложнить задачу контролем классов всех вложенных компонентов, но для нашего примера это не так важно*

Поехали

```jsx
// Придется залезть в библиотеку и сделать пару правок

const MyComponent = (props) => {

    const {rootClassName} = props

    /* Тут ничего не меняется. Пропускаем */

    return <div className={rootClassName}>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// рендерим
<MyComponent rootClassName="custom" />
```

А тем временем в Chorda

```javascript
// Менять оригинальный чертеж необходимости нет

// В месте применения создадим примесь
const blueprint = mix(MyComponent, {
    css: 'custom',
})
```

Естественно, стилизацией дело не закончится. Чем дальше, тем больше пропсов нам понадобится добавить.

На самом деле подобные извращения следует пресекать в зародыше и сразу позволять потребителю "слотировать" вложенные компоненты. Однако, наши компоненты жестко связаны приватной переменной `data`, просто так вытащить их не получится, поэтому посмотрим, во что может превратиться реализация с пропсами

```javascript
const MyComponent = (props) => {

    const {rootProps, buttonProps, text as MyText} = props

    /* тут ничего не меняется */

    return <div {...rootProps} >
        <button onClick={handleClick} {...buttonProps} >Click me</button>
        <MyText>{data}</MyText>
    </div>
}

<MyComponent 
    rootProps={{className: 'custom'}} 
    buttonProps={{className: 'custom-button'}}
    text={props => <p className="custom-text">{props.children}</p>}
    />

```

В работе с чертежом без особых именений. Продолжаем смешивать

```javascript
// Расширяем примесь

const blueprint = mix(MyComponent, {
    css: 'custom',
    templates: {
        button: {
            css: 'custom-button'
        },
        text: {
            css: 'custom-text'
        }
    }
})
```

Для React типовым решением проблемы было бы вынесение состояния из компонента. Получившийся "глупый" компонент уже не будет иметь внутри сильной связи и позволит легко "слотировать" вложения. Но здесь есть подводный камень. Архитектура такая штука, что если где-то убыло, то где-то прибыло. Выбрасывая сложность из наших компонентов мы ее копим в другом месте, а именно там, где компонент будет применяться

Стоит признать, что и с примесями тоже не все так гладко. Чтобы сделать хорошо расширяемый компонент, его необходимо сильно декомпозировать, а это напрямую влияет на производительность и восприятие кода в целом (по второму пункту полезно почитать о причинах появления setup во Vue 3)

Идем дальше. Мы рассмотрели как именно выполняются изменения, но что если вы являетесь уже не автором библиотеки компонентов, а ее потребителем и столкнулись с проблемой нехватки функционала? 

Тогда на выбор:
1. Делаем форк, вносим в него правки. Делаем PR в репо библиотеки. Пока ждем влития, пользуемся форком
2. Делаем свой компонент. Используем его вместо библиотечного. Ждем новой версии библиотеки
3. (для обладателей особого дара убеждения) Объясняем автору библиотеки в чем *он* не прав и почему *он* должен внести нужные *вам* правки как можно скорее
4. Забиваем

Смешивание позволяет добавить еще один вариант. Что-то среднее между 1 и 2. Вы создаете свой компонент, но он как-бы остается частью оригинальной библиотеки и обновляется вмесете с ней


### Mount или не Mount?

Наверно, правильнее задать вопрос так: в какой момент должна начинаться обработка бизнес задач? 

Самый распространенный пример это загрузка первичных данных на странице. Как правило, загрузка выполняется по событию монтирования VDOM узла, что не есть очевидно - зачем что-то рендерить, если данных еще нет?. Ситуацию немного спасает Suspense и понятие асинхронных компонентов, когда редполагается, что у каждого компонента есть своя отложенная задача, и как только она будет выполнена, можно рендериться

В Chorda логика работы находится на уровне компонентов приложения, т.е. бизнес задачи запускаются на этапе, когда структура приложения уже есть, но отрисовка еще не началась. Здесь мы можем остановить, отложить рендеринг или синхонизировать его с другими компонентами


### Все мы вместе и каждый сам по себе

В Chorda состояние компонента определяется только его скоупом, причем сам скоуп является открытым. Это обязательное требование для расширяемых компонентов, т.к. перекрыть или заменить закрытые переменные невозможно.

По умолчанию, скоуп один на всех, все компоненты имеют доступ например к общему роуту, но любой компонент может изменить скоуп для себя и своего поддерева

Стратегия базового конвейера Chorda дает построение дерева компонентов в ширину с удержанием задач отрисовки до окончания обработки всех патчей. Если для вашего приложения такое решение не подходит или вы хотите, к примеру, разделить приложение на блоки, которые отрисовываются независимо друг от друга, для каждого из них можно настроить свой собственный конвейер


## Неочевидные следствия

Появились во время использования. Не являлись изначальной целью.

### Встраивание в существующие проекты

Реализация VDOM не входит в состав Chorda. Разработка еще одного рендерера не решала моих проблем, поэтому предполагалось использовать один из уже существующих. Попробовав несколько вариантов, я дошел до ReactDOM. Для того, чтобы попробовать Chorda в деле, я собирался переписать пару проектов, но после некоторого шаманства выяснилось, что можно не переписывать, а продолжать работу в существующих проектах, постепенно заменяя компоненты и модули на Chorda

Была мысль сделать vdom-agnostic компонент и использовать одну и ту же библиотеку в проектах на разных фреймворках, но пока польза от этого не очевидна


### JSX

Изначально предполагалось, что для описания компонентов будут использоваться классы, но в дальнейшем практика показала, что классы вырождаются сначала в конструкторы, а затем в дизайн-функции. Следующим шагом может оказаться JSX, но исключительно как сахарное представление структуры приложения, которое состоит только из дизайн-функций
