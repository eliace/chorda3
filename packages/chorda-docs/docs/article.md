# Статья


## А в чем проблема?


## Очевидные плюшки

### Расширение библиотечных компонентов

Рассмотрим пример с кнопкой и текстом. По клику по кнопке меняется текст

```javascript
const MyComponent = () => {
    return {
        items: [{
            button: {
                tag: 'button',
                text: 'Click me',
                events: {
                    // обработка событий DOM/VDOM
                    $dom: {
                        click: (evt, {data}) => {
                            data.$value = 'Hello'
                        }
                    }
                }
            },
            text: {
                tag: 'p',
                reactions: {
                    // реакции компонента на изменение переменной скоупа
                    data: v => patch({text: v})
                }
            }
        }],
        injections: {
            // инъекция переменной в скоуп
            data: () => observable('')
        }
    }
}

// чертеж
const blueprint = MyComponent
```

Сделаем похожий функционал с использованием условной рендер-функции и JSX

```jsx
const MyComponent = () => {

    const data = observable('')

    const hahdleClick = (e) => {
        data.$value = 'Hello'
    }

    return <div>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// вот так выглядит применение компонента
<MyComponent/>
```

Все, ребята. Расходимся. Тут все очевидно

Но

Вы сделали компонент не для того, чтобы доказать всем, что умеете. У вас работа. Вы передаете компонент коллеге в составе библиотеки или публикуете в публичный репозитарий. Далее приходит простая просьба: хочу стилизовать компонент. Очевидный и достаточный способ - дать возможность управлять классом корневого компонента. 

Можно усложнить задачу контролем классов всех вложенных компонентов, но сути это не меняет

```jsx
// Придется залезть в библиотеку и сделать пару правок

const MyComponent = (props) => {

    const {rootClassName} = props

    /* Тут ничего не меняется. Пропускаем */

    return <div className={rootClassName}>
        <button onClick={handleClick}>Click me</button>
        <p>{data}</p>
    </div>
}

// рендерим
<MyComponent rootClassName="custom" />
```

Тем временем в Chorda

```javascript
// Менять оригинальный чертеж нет необходимости

// В месте применения создадим примесь
const blueprint = mix(MyComponent, {
    css: 'custom',
})
```

Естественно, стилизацией дело не заканчивается. Чем дальше, тем больше пропсов нам будет нужно добавить.

На самом деле подобные извращения следует пресекать как можно раньше и позволять потребителю "слотировать" вложенный компонент. Однако, в нашем примере вложения жестко связаны приватной переменной `data`, просто так вытащить их не получится, поэтому будем работать с пропсами

```javascript
const MyComponent = (props) => {

    const {rootProps, buttonProps, text} = props

    /* тут ничего не меняется */

    return <div {...rootProps} >
        <button onClick={handleClick} {...buttonProps} >Click me</button>
        <text>{data}</text>
    </div>
}

<MyComponent 
    rootProps={{className: 'custom'}} 
    buttonProps={{className: 'custom-button'}}
    text={props => <p className="custom-text">{props.children}</p>}
    />

```

В Chorda без особых именений. Продолжаем смешивать

```javascript
// Расширяем примесь

const blueprint = mix(MyComponent, {
    css: 'custom',
    templates: {
        button: {
            css: 'custom-button'
        },
        text: {
            css: 'custom-text'
        }
    }
})
```

Для React типовым решением проблемы будет вынесение состояния из компонента. Новый "глупый" компонент уже не будет иметь внутри сильной связи и позволит легко "слотировать" вложения. Но здесь есть подводный камень. Архитектура такая штука, что если где-то убыло, то где-то прибыло. Выбрасывая сложность из наших компонентов мы ее копим в другом месте

С примесями тоже далеко не все хорошо. Проблемы наступают, когда вы начинаете использовать дизайн-функции с пропсами. В какой-то момент в месте применения пропсы становятся неотличимы от опций, возникает путаница

Пр работе с дизайн-функцией явная схожесть с рендер-функцией React - на вход подаем набор пропсов, в ответ получаем неведомую хрень. Но, если рендер-функция выдает VDOM ноду (тут, конечно, HOC-и могут с этим поспорить), то дизайн функция возвращает чертеж, который еще даже не является компонентом





### Mount или не Mount?

Наверно, правильнее задать вопрос так: в какой момент должна начинаться обработка бизнес задач? 

Самый очевидный пример это загрузка первичных данных на странице. Как правило, загрузка выполняется по событию монтирования VDOM узла, что не есть очевидно. Ситуацию немного спасает Suspense. Так, к примеру, Vue вводит понятие асинхронных компонентов и отложенной задачи рендеринга. Предполагается, что у каждого компонента своя задача, и как только она выполнена, можно рендериться

В Chorda инициализация обычно выполняется в `joint`-ах, т.к:

1. `joint`-ы не связаны с рендерингом, а только с инициализацией дерева компонентов

2. `joint`-ы настраивают взаимосвязи между переменными скоупа, что как нельзя кстати в случае, если наши загружаемые данные захватывают несколько компонентов


### Каждый сам по себе

Состояние компонента определяется только его скоупом. Это обязательное требование для расширяемых компонентов, т.к. невозможно перекрыть или заменить приватные переменные.

Каждый компонент может иметь свой собственный изолированный движок (конвейер обработки). 


## Сомнительные плюшки

Появились во время использования. Не являлись изначальной целью.

### Встраивание в существующие проекты

Реализация VDOM не входит в состав Chorda. Разработка еще одного рендерера не решала моих проблем, поэтому предполагалось использовать уже существующий. Попробовав несколько вариантов, я дошел до ReactDOM. Для того, чтобы попробовать Chorda в деле, я собирался переписать пару проектов, но после некоторого шаманства выяснилось, что можно не переписывать, а продолжать разработку в существующем проекте, постепенно заменяя компоненты и модули на Chorda

Была мысль сделать vdom-agnostic компонент и использовать одну и ту же библиотеку в проектах на разных фреймворках, но пока не вижу в этом большого смысла

### Тестирование бизнес-логики

Поскольку логика работы приложения в Chorda отвязана от отрисовки, ее можно проверить без реального рендеринга
