---
sidebar_position: 2
---
# Дерево компонентов

Невозможно заглянуть в опции дочернего компонента, т.к. до момента примененения итоговая кофигурация является неопределенной. Одним из следствий этого оказывается то, что сам компонент не может знать, является ли он частью дерева в данный момент. 

##### Именованные и индексированные компоненты

Почему нельзя использовать список дочерних элементов?

Обычная работа с дочерними элементами сводится к созданию:
1. Набора однотипных элементов, как правило упорядоченных
2. Набора разных элементов, часть из которых включена, а часть отключена
3. Комбинации 1 и 2 вариантов

```javascript
export default () => {
    return {
        // индексированные компоненты
        items: [
            {text: '1'},
            {text: '2'},
            {text: '3'},
        ],
        defaultItem: {
            tag: 'a',
            css: 'page-num',
        },
        // именованные компоненты
        components: {
            prev: {
                weight: -10,
                text: '<',
            },
            next: {
                weight: 10,
                text: '>',
            }
        },
        defaultComponent: {
            tag: 'a',
        }
    }
}

```

##### Управление шаблонами

```javascript
export default () => {
    return {
        templates: {
            header: { text: 'Title' },
            body: { text: 'Content' },
            footer: { text: 'Footer' }
        },
        components: {
            header: true,
            body: true,
            footer: false, // подвал отключаем
        }
    }
}
```

Смесь конфигурации создается таким образом: 

[ **defaultComponent**, **templates[name]**, **components[name]** ]

В нашем примере последний компонент принимает значение **false**, т.е. при сборке вся смесь оказывается пустой и создание компонента игнорируется

:::tip
Вследствие такого подхода, обычно компоненты определяются с помощью `templates`, а `components` используется для управления включением компонентов в дерево
:::


### Фабрика компонентов

Вызывается контейнером при создании дочерних компонентов. Может понадобиться, если у вас есть свои классы компонентов

### Вес компонента

Именованные компоненты не имеют порядка. Порядок может быть задач через опцию `weight`. Это не совсем порядок, а весовой коэффициент. По умолчанию вес считается равным 0. Компоненты внутри одной весовой группы не имеют четкого порядка

```javascript
export default () => {
    return {
        templates: {
            // компоненты будут отрисованы упорядоченно
            header: {weight: -10},
            body: {weight: 0},
            footer: {weight: 10},
        }
    }
}
```

### Фильтрация и сортировка

При изменении списка дочерних компонентов происходит их упорядочивание. По умолчанию для выстраивания порядка используются веса и индексы