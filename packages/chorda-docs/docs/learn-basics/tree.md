---
sidebar_position: 2
---
# Компоненты


### Структура

Невозможно заглянуть в опции дочернего компонента, т.к. до момента примененения итоговая кофигурация является неопределенной. Одним из следствий этого оказывается то, что сам компонент не может знать, является ли он частью дерева в данный момент. 

### Именованные и индексированные компоненты

Почему нельзя использовать список дочерних элементов?

Обычная работа с дочерними элементами сводится к созданию:
1. Набора однотипных элементов, как правило упорядоченных
2. Набора разных элементов, часть из которых включена, а часть отключена
3. Комбинации 1 и 2 вариантов

```javascript
export default () => {
    return {
        // индексированные компоненты
        items: [
            {text: '1'},
            {text: '2'},
            {text: '3'},
        ],
        defaultItem: {
            tag: 'a',
            css: 'page-num',
        },
        // именованные компоненты
        components: {
            prev: {
                weight: -10,
                text: '<',
            },
            next: {
                weight: 10,
                text: '>',
            }
        },
        defaultComponent: {
            tag: 'a',
        }
    }
}

```

### Управление шаблонами

```javascript
export default () => {
    return {
        templates: {
            header: { text: 'Title' },
            body: { text: 'Content' },
            footer: { text: 'Footer' }
        },
        components: {
            header: true,
            body: true,
            footer: false, // подвал отключаем
        }
    }
}
```

Смесь конфигурации создается таким образом: 

[ **defaultComponent**, **templates[name]**, **components[name]** ]

В нашем примере последний компонент *components[footer]* принимает значение **false**, т.е. при сборке вся смесь оказывается пустой и создание компонента игнорируется

:::tip
Вследствие такого подхода, обычно компоненты определяются с помощью `templates`, а `components` используется для управления включением компонентов в дерево
:::

### Изменение структуры

Структура меняется только через систему реакций и вспомогательный метод `patch`.

#### Проекция опций

Используется для `items` и `components`. Переменная содержит набор опций, которые будут использованы для создания вложенных компонентов

```javascript
export default () => {
    return {
        initials: {
            data: () => observable([{/* опции 1 */}, {/* опции 2 */}])
        },
        reactions: {
            data: (v) => patch({items: v})
        }
    }
}
```

С именованными компонентами ситуация схожа

```javascript
export default () => {
    return {
        initials: {
            isShowHeader: () => observable(false)
        },
        reactions: {
            isShowHeader: (v) => patch({
                components: {
                    header: v
                }
            })
        }
    }
}
```

:::tip
Именованные компоненты обладают свойством **аддитивности**. Это означает, что частичные патчи `components` не удаляют предыдущие значения, а сливаются с ними. В отличие от `items`, где новый патч заменяет старое значение 
:::

#### Проекция скоупа

Если в качестве нового значения `items` передается итерируемая переменная, то ее элементы используются не как опции, а как часть скоупа вложенных компонентов

```javascript
export default () => {
    return {
        initials: {
            data: () => iterable([{/* значения 1 */}, {/* значения 2 */}])
        },
        reactions: {
            data: (v) => patch({items: v})
        }
    }
}
```


### Фабрика компонентов

Вызывается контейнером при создании дочерних компонентов. Может понадобиться, если у вас есть свои классы компонентов

### Вес компонента

Именованные компоненты не имеют порядка. Порядок может быть задач через опцию `weight`. Это не совсем порядок, а весовой коэффициент. По умолчанию вес считается равным 0. Компоненты внутри одной весовой группы не имеют четкого порядка

```javascript
export default () => {
    return {
        templates: {
            // компоненты будут отрисованы упорядоченно
            header: {weight: -10},
            body: {weight: 0},
            footer: {weight: 10},
        }
    }
}
```

### Фильтрация и сортировка

При изменении списка дочерних компонентов происходит их упорядочивание. По умолчанию для выстраивания порядка используются веса и индексы

Индексированные и именованные компоненты собираются в список дочерних компонентов

Дочерние компоненты можно отфильтровать и отсортировать

```javascript
export default () => {
    return {
        items: ['Alice', 'Bob', 'Charlie'],
        childFilter: (child => {
            return child.index != 1 // исключаем компонент с индексом 1
        }),
        childSorter: (a, b) => {
            return a.index > b.index
        }
    }
}
```

По умолчанию фильтрация отключена, а сортировка выполняется с учетом `options.weight` и `index`


