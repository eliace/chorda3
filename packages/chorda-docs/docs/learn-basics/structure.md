---
sidebar_position: 2
---
# Компоненты

:::info Зачем нам нужны компоненты?
Вопрос может показаться странным, но у него есть свои причины. Примитивное представление о реактивной разработке в веб-е говорит нам о том, что есть **данные** (состояние) и есть **разметка** (DOM), а больше ничего не нужно. Данные поменялись, разметка тоже поменялась. 

Этот подход отлично работает, если брать в расчет только свойства элементов разметки (атрибуты, классы, стили и т.д.), но если мы взглянем на структур приложения в целом, то станет понятно, что разметка и данные не ложатся один-в-один друг на друга, необходимо преобразование. Такое преобразование предоставляет, например, механизм шаблонов, где правила тем или иным способом встроены в разметку. Получается связка:

`Данные` + `Разметка + Преобразование`

Можно пойти с другой стороны и оставить "чистую" разметку, перенеся преобразование на уровень данных. Внедряя логику компонентов в слой данных, мы разбиваем состояние на прикладное и на состояние отрисовки. Получаем такую ситуацию:

`Данные + Преобразование` + `Разметка`

В Chorda компонентный слой существует самостоятельно:

`Данные` + `Преобразование` + `Разметка`

:::

:::caution
Поскольку в Chorda нет **this**, то прямого доступа к дочерним и родительским компонентам тоже нет
:::

## Виды компонентов


### Индексированные компоненты

### Именованные компоненты

:::caution
В опции дочернего компонента заглянуть невозможно, т.к. до момента примененения итоговая конфигурация является неизвестной. Следствием этого является то, что мы не можем использовать для условного конструирования опции дочернего компонента до его создания
:::


Почему нельзя использовать список дочерних элементов?

Обычная работа с дочерними элементами сводится к созданию:
1. Набора однотипных элементов, как правило упорядоченных
2. Набора разных элементов, часть из которых включена, а часть отключена
3. Комбинации 1 и 2 вариантов

```javascript
export default () => {
    return {
        // индексированные компоненты
        items: [
            {text: '1'},
            {text: '2'},
            {text: '3'},
        ],
        defaultItem: {
            tag: 'a',
            css: 'page-num',
        },
        // именованные компоненты
        components: {
            prev: {
                weight: -10,
                text: '<',
            },
            next: {
                weight: 10,
                text: '>',
            }
        },
        defaultComponent: {
            tag: 'a',
        }
    }
}

```


## Примеры компоновки

Как можно выполнить требуемую компоновку

### Список

`li` + `li` + `li` + `li`

Последовательность однотипных элементов

```javascript
const blueprint = {
    defaultItem: {
        tag: 'li'
    },
    items: [{}, {}, {}, {}]
}
```

### Набор

`div` + `span` + `p` + `button`

Множество разнотипных элементов. В большинстве случаев не связанных друг с другом ни структурно, ни по смыслу

```javascript
const blueprint = {
    items: [
        {tag: 'div'}, 
        {tag: 'span'}, 
        {tag: 'p'},
        {tag: 'button'},
    ]
}
```

или

```javascript
const blueprint = {
    components: {
        a: {tag: 'div'}, 
        b: {tag: 'span'}, 
        c: {tag: 'p'},
        d: {tag: 'button'},
    }
}
```

Выбор зависит от того типа данных, которым вы хотите управлять компонентами: `Array` или `Object`

### Список с аддонами

**`span`** + `li` + `li` + `li` + `li` + **`span`**

"Декорированный" список. В нем нам хочется разделить управление самим списком и его дополнениями 

```javascript
const blueprint = {
    defaultItem: {
        tag: 'li'
    },
    items: [{}, {}, {}, {}],
    components: {
        before: {tag: 'span'},
        after: {tag: 'span'},
    }
}
```

### Уплощенный (flatten) список

**`input` + `label`** + `input` + `label` + **`input` + `label`** + `input` + `label`

Особенности верстки

```javascript
const blueprint = {
    defaultItem: {
        layout: passthruLayout,
        components: {
            check: {tag: 'input'},
            label: {tag: 'label'},
        }
    },
    items: [{}, {}, {}, {}],
}
```

Используется компоновка **passthruLayout**, которая говорит, что компонент исключен из отрисовки, а его дочерние компоненты передаются родительскому

## Структура


### Управление шаблонами

```javascript
export default () => {
    return {
        templates: {
            header: { text: 'Title' },
            body: { text: 'Content' },
            footer: { text: 'Footer' }
        },
        components: {
            header: true,
            body: true,
            footer: false, // подвал отключаем
        }
    }
}
```

Смесь конфигурации создается таким образом: 

Опции компонента foo = **defaultComponent** + **templates**[foo] + **components**[foo]

В нашем примере последний компонент *components[footer]* принимает значение **false**, т.е. при сборке вся смесь оказывается пустой и создание компонента игнорируется

:::tip
Вследствие такого подхода, обычно компоненты определяются с помощью `templates`, а `components` используется для управления включением компонентов в дерево
:::

### Изменение структуры

Структура меняется только через систему реакций и вспомогательный метод `patch`.

#### Проекция опций

Используется для `items` и `components`. Переменная содержит набор опций, которые будут использованы для создания вложенных компонентов

```javascript
export default () => {
    return {
        initials: {
            data: () => observable([{/* опции 1 */}, {/* опции 2 */}])
        },
        reactions: {
            data: (v) => ({items: v})
        }
    }
}
```

С именованными компонентами ситуация схожа

```javascript
export default () => {
    return {
        initials: {
            isShowHeader: () => observable({header: false})
        },
        reactions: {
            isShowHeader: (v) => ({components: v})
        }
    }
}
```

:::tip
Именованные компоненты обладают свойством **аддитивности**. Это означает, что частичные патчи `components` не удаляют предыдущие значения, а сливаются с ними. В отличие от `items`, где новый патч заменяет старое значение 
:::

#### Проекция скоупа

Когда мы пережаем в `components`/`items` новые значения, то создаются дочерние компоненты с тем же скоупом, что и у родительского компонента. Для того, чтобы изменить правило передачи скоупа, используются проекции


```javascript
export default () => {
    return {
        initials: {
            data: () => observable([{/* значение 1 */}, {/* значение 2 */}])
        },
        reactions: {
            data: (v) => ({items: iterator(v)})
        }
    }
}
```



