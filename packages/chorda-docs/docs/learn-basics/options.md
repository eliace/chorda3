---
sidebar_position: 1
---

# Опции

### Конфигурация

```javascript

const html = new Html({
    tag: 'div'
})

```

Конфигурации могут иметь несколько интерпретируемых представлений:
- `HtmlOptions` - собственно конфигурация
- `string` - краткая форма для {text: "строковое_значение"}
- `boolean` - значение false отменяет предыдущие конфигурации в смеси
- `Function` - дизайн-функция
- `Promise` - отложенная дизайн-функция
- `Mixed<HtmlOptions|Function|Promise|string|boolean>` - смесь конфигураций

Поскольку компоненты в качестве конфигурации принимают только `HtmlOptions`, это означает, что необходима предварительная сборка


Несколько конфигураций можно смешать вместе

```javascript
const mixedOptions = mixin({name: 'myComponent'}, MyComponent, 'Hello')
```

Смесь предаставляет из себя список конфигураций. Их объединение произойдет только в момент использования. Правила применения зависят от компонента

```javascript
// Link.js
export default () => {
    return {
        tag: 'a'
    }
}

// App.js
import Link from "./Link"

const app = new Html(Link())

```


### Опции скоупа

#### Реактивность компонентов

Подписку на изменения наблюдаемой переменной можно выполнить с помощью блока `reactions`

```javascript
export default () => {
    return {
        initials: {
            // инициируем переменную в скоупе
            data: () => observable('')
        },
        reactions: {
            // реакции компонента на изменение переменной скоупа
            data: v => patch({text: v})
        }
    }
}

```

Метод `patch` помещает задание в очередь патчей. Заданием по сути будет применение указанных опций к компоненту

#### Инъекция переменных

```javascript

export default () => {
    return {
        injections: {
            cn: (scope) => scope.data  // достаем переменную data из скоупа
        },
        reactions: {
            cn: (v) => patch({
                classes: {
                    [v]: !!v  // включаем/выключаем класс
                } 
            })
        }
    }
}
```

Принципиальное отличие блоков `initials` от `injections` состоит в том, что второй принимает в качестве аргумента скоуп компонента

#### События

В компонентах событий как таковых нет. Функционалом событийной шины могут обладать переменные скоупа. на эти события можно подписаться с помощью блока `events` с указанием переменной, на которую выполняется подписка

```javascript

const timer = observable(null)

setTimeout(() => timer.$emit('tick'), 100)

export default () => {
    return {
        initials: {
            data: () => timer
        },
        events: {
            data: {
                tick: () => {
                    // обработчик будет вызван через 100мс
                }
            }
        }
    }
}

```




### Опции структуры

##### Именованные и индексированные компоненты

Почему нельзя использовать список дочерних элементов?

Обычная работа с дочерними элементами сводится к созданию:
1. Набора однотипных элементов, как правило упорядоченных
2. Набора разных элементов, часть из которых включена, а часть отключена
3. Комбинации 1 и 2 вариантов

```javascript
export default () => {
    return {
        // индексированные компоненты
        items: [
            {text: '1'},
            {text: '2'},
            {text: '3'},
        ],
        defaultItem: {
            tag: 'a',
            css: 'page-num',
        },
        // именованные компоненты
        components: {
            prev: {
                weight: -10,
                text: '<',
            },
            next: {
                weight: 10,
                text: '>',
            }
        },
        defaultComponent: {
            tag: 'a',
        }
    }
}

```

##### Управление шаблонами

```javascript
export default () => {
    return {
        templates: {
            header: { text: 'Title' },
            body: { text: 'Content' },
            footer: { text: 'Footer' }
        },
        components: {
            header: true,
            body: true,
            footer: false, // подвал отключаем
        }
    }
}
```

Смесь конфигурации создается таким образом: 

[ **defaultComponent**, **templates[name]**, **components[name]** ]

В нашем примере последний компонент принимает значение **false**, т.е. при сборке вся смесь оказывается пустой и создание компонента игнорируется

:::tip
Вследствие такого подхода, обычно компоненты определяются с помощью `templates`, а `components` используется для управления включением компонентов в дерево
:::


### Опции отрисовки

Основные

```javascript
export default () => {
    return {
        // свойства VDOM, зависят от выбранного рендерера
        dom: {
            className: 'custom',
        },
        // вспомогательные свойства, универсальные. Дополняют свойства VDOM
        tag: 'span',
        text: 'Привет!!!',
        css: 'my-custom-class'
    }
}
```
