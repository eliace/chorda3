{"version":3,"sources":["webpack://ChordaEngine/webpack/universalModuleDefinition","webpack://ChordaEngine/../chorda-core/lib/index.js","webpack://ChordaEngine/../chorda-core/lib/src/Blueprint.js","webpack://ChordaEngine/../chorda-core/lib/src/Gear.js","webpack://ChordaEngine/../chorda-core/lib/src/Html.js","webpack://ChordaEngine/../chorda-core/lib/src/Hub.js","webpack://ChordaEngine/../chorda-core/lib/src/engine/index.js","webpack://ChordaEngine/../chorda-core/lib/src/index.js","webpack://ChordaEngine/../chorda-core/lib/src/mix/Mixin.js","webpack://ChordaEngine/../chorda-core/lib/src/mix/index.js","webpack://ChordaEngine/../chorda-core/lib/src/mix/utils.js","webpack://ChordaEngine/../chorda-core/lib/src/pipe/async.js","webpack://ChordaEngine/../chorda-core/lib/src/pipe/buffered.js","webpack://ChordaEngine/../chorda-core/lib/src/pipe/index.js","webpack://ChordaEngine/../chorda-core/lib/src/pipe/pipe.js","webpack://ChordaEngine/../chorda-core/lib/src/pipe/utils.js","webpack://ChordaEngine/../chorda-core/lib/src/reconcile.js","webpack://ChordaEngine/../chorda-core/lib/src/render/index.js","webpack://ChordaEngine/../chorda-core/lib/src/render/node.js","webpack://ChordaEngine/../chorda-core/lib/src/render/utils.js","webpack://ChordaEngine/../chorda-core/lib/src/rules.js","webpack://ChordaEngine/../chorda-core/lib/src/value/bus.js","webpack://ChordaEngine/../chorda-core/lib/src/value/callable.js","webpack://ChordaEngine/../chorda-core/lib/src/value/computable.js","webpack://ChordaEngine/../chorda-core/lib/src/value/engine.js","webpack://ChordaEngine/../chorda-core/lib/src/value/index.js","webpack://ChordaEngine/../chorda-core/lib/src/value/iterable.js","webpack://ChordaEngine/../chorda-core/lib/src/value/iterator.js","webpack://ChordaEngine/../chorda-core/lib/src/value/node.js","webpack://ChordaEngine/../chorda-core/lib/src/value/observable.js","webpack://ChordaEngine/../chorda-core/lib/src/value/pubsub.js","webpack://ChordaEngine/../chorda-core/lib/src/value/utils.js","webpack://ChordaEngine/./src/engine.ts","webpack://ChordaEngine/./src/engine2.ts","webpack://ChordaEngine/./src/index.ts","webpack://ChordaEngine/webpack/bootstrap","webpack://ChordaEngine/webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;ACVa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,8CAAO;AAC5B,iC;;;;;;;;;;ACba;AACb;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,WAAW;AACpF,aAAa,mBAAO,CAAC,8CAAQ;AAC7B,YAAY,mBAAO,CAAC,kDAAO;AAC3B,aAAa,mBAAO,CAAC,oDAAQ;AAC7B;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc;AACd,qC;;;;;;;;;;AC1Ca;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY,GAAG,cAAc,GAAG,uBAAuB,GAAG,yBAAyB,GAAG,wBAAwB,GAAG,0BAA0B;AAC3I,YAAY,mBAAO,CAAC,kDAAO;AAC3B,YAAY,mBAAO,CAAC,4CAAO;AAC3B,cAAc,mBAAO,CAAC,gDAAS;AAC/B,cAAc,mBAAO,CAAC,sDAAS;AAC/B,kBAAkB,mBAAO,CAAC,wDAAa;AACvC;AACA;AACA;AACA,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6GAA6G,0BAA0B,EAAE;AACzI;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ,gC;;;;;;;;;;AC9ca;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,0BAA0B,GAAG,6BAA6B,GAAG,4BAA4B;AACjL,SAAS,mBAAO,CAAC,0CAAG;AACpB,aAAa,mBAAO,CAAC,8CAAQ;AAC7B,eAAe,mBAAO,CAAC,wDAAU;AACjC,cAAc,mBAAO,CAAC,gDAAS;AAC/B,4BAA4B,aAAa,wCAAwC;AACjF,6BAA6B,aAAa,wCAAwC;AAClF;AACA;AACA;AACA,0BAA0B;AAC1B,qCAAqC,6CAA6C;AAClF,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,iDAAiD,EAAE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD,YAAY;AACZ,gC;;;;;;;;;;ACzMa;AACb;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,WAAW,GAAG,aAAa,GAAG,aAAa;AAC3C,cAAc,mBAAO,CAAC,sDAAS;AAC/B,YAAY,mBAAO,CAAC,kDAAO;AAC3B,aAAa,mBAAO,CAAC,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B,aAAa,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,mCAAmC,kBAAkB;AACrD;AACA;AACA,+CAA+C;AAC/C;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,wDAAwD;AACxD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uBAAuB;AAC3E;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gCAAgC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,WAAW;AACX,+B;;;;;;;;;;AC9iBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iC;;;;;;;;;;ACFa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,4CAAO;AAC5B,aAAa,mBAAO,CAAC,8CAAQ;AAC7B,aAAa,mBAAO,CAAC,8CAAQ;AAC7B,aAAa,mBAAO,CAAC,4CAAO;AAC5B,aAAa,mBAAO,CAAC,wDAAa;AAClC,aAAa,mBAAO,CAAC,sDAAS;AAC9B,aAAa,mBAAO,CAAC,wDAAU;AAC/B,aAAa,mBAAO,CAAC,wDAAU;AAC/B,aAAa,mBAAO,CAAC,kDAAO;AAC5B,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,iC;;;;;;;;;;ACtBa;AACb;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,eAAe,GAAG,aAAa,GAAG,0BAA0B,GAAG,aAAa;AAC5E,cAAc,mBAAO,CAAC,uDAAU;AAChC,cAAc,mBAAO,CAAC,oDAAS;AAC/B;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,aAAa;AACb;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,KAA+B,EAAE,EAEpC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,iC;;;;;;;;;;AC7Ha;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,oDAAS;AAC9B,aAAa,mBAAO,CAAC,oDAAS;AAC9B,iC;;;;;;;;;;ACda;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB,GAAG,iBAAiB;AACrC,cAAc,mBAAO,CAAC,uDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iC;;;;;;;;;;AC3Ga;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,mBAAmB;AACnB,cAAc,mBAAO,CAAC,qDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,sBAAsB,EAAE;AAC/F;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,mBAAmB;AACnB,iC;;;;;;;;;;AC7Ea;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,sBAAsB;AACtB,cAAc,mBAAO,CAAC,qDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,sBAAsB,EAAE;AAC/F;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,sBAAsB;AACtB,oC;;;;;;;;;;ACpDa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,qDAAS;AAC9B,aAAa,mBAAO,CAAC,qDAAS;AAC9B,aAAa,mBAAO,CAAC,2DAAY;AACjC,aAAa,mBAAO,CAAC,mDAAQ;AAC7B,iC;;;;;;;;;;AChBa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,YAAY;AACZ,gC;;;;;;;;;;ACzCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,yBAAyB,GAAG,8BAA8B,GAAG,qBAAqB,GAAG,eAAe;AACpG;AACA,YAAY;AACZ;AACA,eAAe;AACf,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,qBAAqB;AACrB,uDAAuD;AACvD,oDAAoD,2BAA2B,EAAE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,8BAA8B;AAC9B,kDAAkD;AAClD;AACA;AACA,KAAK;AACL,EAAE;AACF,yBAAyB;AACzB,iC;;;;;;;;;;ACpCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB,GAAG,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC,sBAAsB;AAC5D,mBAAmB,sBAAsB;AACzC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB,qC;;;;;;;;;;AC/Ja;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,uDAAS;AAC9B,aAAa,mBAAO,CAAC,qDAAQ;AAC7B,iC;;;;;;;;;;ACda;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,eAAe;AACf,cAAc,mBAAO,CAAC,uDAAU;AAChC,eAAe,mBAAO,CAAC,+DAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,Y;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sCAAsC,EAAE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,eAAe;AACf,gC;;;;;;;;;;ACjHa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,iC;;;;;;;;;;ACvCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB;AACpB,YAAY,mBAAO,CAAC,kDAAO;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;ACpGa;AACb;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yDAAyD,EAAE;AACxH;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iBAAiB;AACjB,+B;;;;;;;;;;AClEa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB,GAAG,gBAAgB;AACrC,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,mBAAmB,mBAAO,CAAC,gEAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB,oC;;;;;;;;;;ACjJa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB;AAClB,eAAe,mBAAO,CAAC,wDAAU;AACjC,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,mBAAmB,mBAAO,CAAC,gEAAc;AACzC,cAAc,mBAAO,CAAC,sDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,kBAAkB;AAClB,sC;;;;;;;;;;AC9Ka;AACb;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,oBAAoB,GAAG,0BAA0B,GAAG,0BAA0B,GAAG,wBAAwB,GAAG,uBAAuB;AACnI,cAAc,mBAAO,CAAC,sDAAS;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,oCAAoC;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oBAAoB;AACpB,kC;;;;;;;;;;ACtHa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,sDAAS;AAC9B,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,aAAa,mBAAO,CAAC,gEAAc;AACnC,aAAa,mBAAO,CAAC,gEAAc;AACnC,aAAa,mBAAO,CAAC,4DAAY;AACjC,aAAa,mBAAO,CAAC,4DAAY;AACjC,aAAa,mBAAO,CAAC,4DAAY;AACjC,aAAa,mBAAO,CAAC,wDAAU;AAC/B,iC;;;;;;;;;;ACpBa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB,GAAG,gBAAgB,GAAG,oBAAoB;AAC5D,aAAa,mBAAO,CAAC,oDAAQ;AAC7B,mBAAmB,mBAAO,CAAC,gEAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,+CAA+C,mBAAmB;AAClE;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,gB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB;AACpB;AACA,yBAAyB,cAAc;AACvC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB,oC;;;;;;;;;;ACxFa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,+BAA+B;AAC/B,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;;;;AC/Da;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,YAAY,GAAG,kBAAkB,GAAG,eAAe,GAAG,gBAAgB,GAAG,uBAAuB;AAChG,cAAc,mBAAO,CAAC,sDAAS;AAC/B,eAAe,mBAAO,CAAC,wDAAU;AACjC,eAAe,mBAAO,CAAC,wDAAU;AACjC;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA;AACA,CAAC,gCAAgC,eAAe,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oKAAoK;AACpK,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ,gC;;;;;;;;;;ACvfa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,eAAe,GAAG,iBAAiB,GAAG,iBAAiB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,sBAAsB,GAAG,yBAAyB;AAC5Q,aAAa,mBAAO,CAAC,oDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kCAAkC,sBAAsB;AACxD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8GAA8G;AAC9G;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe;AACf,sC;;;;;;;;;;ACzQa;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,cAAc,GAAG,wBAAwB;AACzC,YAAY,mBAAO,CAAC,kDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,yGAAyG,EAAE;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,cAAc;AACd,kC;;;;;;;;;;ACjGa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,kBAAkB,GAAG,sBAAsB,GAAG,aAAa;AAC3D,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB,iC;;;;;;;;;;ACrCa;AACb,8CAA6C,CAAC,cAAc,EAAC;AAC7D,0BAA0B,GAAG,oBAAoB;AACjD,aAAa,mBAAO,CAAC,iDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mCAAmC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,8DAA8D,YAAY,EAAE;AAC5E;AACA;AACA;AACA,2DAA2D,0DAA0D,EAAE;AACvH;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;AC9Eb;AACb;AACA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA6C,CAAC,cAAc,EAAC;AAC7D,0BAA0B,GAAG,mBAAmB;AAChD,aAAa,mBAAO,CAAC,iDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mBAAmB;AACnB;AACA;AACA;AACA,0BAA0B;;;;;;;;;;;ACvDb;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,CAAC,cAAc,EAAC;AAC7D,aAAa,mBAAO,CAAC,iCAAU;AAC/B,aAAa,mBAAO,CAAC,mCAAW;;;;;;;UCbhC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCtBA;UACA;UACA;UACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ChordaEngine\"] = factory();\n\telse\n\t\troot[\"ChordaEngine\"] = factory();\n})(self, function() {\nreturn ","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./src\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attach = exports.createHtmlContext = exports.createHtmlOptions = exports.mix = void 0;\nvar Html_1 = require(\"./Html\");\nvar mix_1 = require(\"./mix\");\nvar pipe_1 = require(\"./pipe\");\nvar mix = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return mix_1.mixin.apply(_this, args);\n};\nexports.mix = mix;\n// export const mix2 = <T, X>(a: HtmlBlueprint<T>, b?: HtmlBlueprint<X>) : Mixed<HtmlBlueprint<T&X>> => {\n//     return mixin(b as any, a as any) as Mixed<HtmlBlueprint<T&X>>\n// }\nvar createHtmlOptions = function (blueprint) {\n    var b = mix_1.mixin(blueprint).build(Html_1.defaultHtmlInitRules);\n    if (typeof b === 'boolean') {\n        return null;\n    }\n    return b;\n};\nexports.createHtmlOptions = createHtmlOptions;\nvar createHtmlContext = function (patcher, renderer) {\n    return {\n        $defaultFactory: Html_1.defaultHtmlFactory,\n        $defaultLayout: Html_1.defaultLayout,\n        $engine: patcher,\n        $renderer: renderer,\n        $pipe: pipe_1.pipe(patcher, renderer)\n    };\n};\nexports.createHtmlContext = createHtmlContext;\nvar attach = function (html, el) {\n    document.addEventListener('DOMContentLoaded', function () {\n        html.attach(el());\n    });\n};\nexports.attach = attach;\n//# sourceMappingURL=Blueprint.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Gear = exports.isGear = exports.defaultGearSort = exports.defaultPatchRules = exports.defaultInitRules = exports.defaultGearFactory = void 0;\nvar mix_1 = require(\"./mix\");\nvar Hub_1 = require(\"./Hub\");\nvar rules_1 = require(\"./rules\");\nvar value_1 = require(\"./value\");\nvar reconcile_1 = require(\"./reconcile\");\nvar defaultGearFactory = function (opts, context, scope, rules) {\n    return new Gear(opts, context, scope);\n};\nexports.defaultGearFactory = defaultGearFactory;\nexports.defaultInitRules = {\n    defaultItem: rules_1.DefaultRules.Option,\n    defaultComponent: rules_1.DefaultRules.Option,\n    components: rules_1.DefaultRules.OptionCollection,\n    templates: rules_1.DefaultRules.OptionCollection,\n};\nexports.defaultPatchRules = {\n    defaultItem: rules_1.DefaultRules.OptionCollectionOverlap,\n    defaultComponent: rules_1.DefaultRules.OptionCollectionOverlap,\n    components: rules_1.DefaultRules.OptionCollectionOverlap,\n    templates: rules_1.DefaultRules.OptionCollectionOverlap,\n    items: rules_1.DefaultRules.Overlap,\n};\nfunction defaultGearSort(a, b) {\n    var w1 = (a.options && a.options.weight) || 0;\n    var w2 = (b.options && b.options.weight) || 0;\n    if (w1 == w2) {\n        var i1 = a.index || 0;\n        var i2 = b.index || 0;\n        return i1 - i2;\n    }\n    return w1 - w2;\n}\nexports.defaultGearSort = defaultGearSort;\nvar isGear = function (obj) {\n    return obj != null && obj.addIndexed != null;\n};\nexports.isGear = isGear;\nvar Gear = /** @class */ (function (_super) {\n    __extends(Gear, _super);\n    function Gear(options, context, scope) {\n        var _this = _super.call(this, options, context, scope) || this;\n        _this.components = {};\n        _this.items = [];\n        return _this;\n    }\n    Gear.prototype.patch = function (optPatch) {\n        _super.prototype.patch.call(this, optPatch);\n        var o = this.options;\n        // console.log(optPatch)\n        // console.log(o)\n        if (optPatch.templates != null) {\n            if (o.components && o.components !== true) {\n                // пересоздаем компоненты\n                for (var k in optPatch.templates) {\n                    // if (this.components[k]) {\n                    //     this.updateComponent(k, o.components[k] as B)\n                    // }\n                    //                    console.log('template component', k, o.components[k])\n                    if (o.components[k] === undefined) {\n                        this.addKeyed(k, null);\n                    }\n                }\n            }\n            else if (o.components == null) {\n                // создаем компоненты по умолчанию\n                for (var k in optPatch.templates) {\n                    this.addKeyed(k, null);\n                }\n            }\n        }\n        if (optPatch.components != null) {\n            if (o.components === true) {\n                for (var k in o.templates) {\n                    this.addKeyed(k, null);\n                }\n            }\n            else if (o.components === false) {\n                // TODO здесь мы должны выключать все компоненты\n            }\n            else {\n                this.syncKeyed(o.components);\n            }\n        }\n        if (optPatch.items) {\n            if (o.items === true) {\n            }\n            else if (o.items === false) {\n            }\n            else {\n                this.syncIndexed(o.items);\n            }\n        }\n    };\n    Gear.prototype.initRules = function () {\n        return exports.defaultInitRules;\n    };\n    Gear.prototype.patchRules = function () {\n        return exports.defaultPatchRules;\n    };\n    //-----------------------\n    // Keyed\n    //-----------------------\n    Gear.prototype.addKeyed = function (key, blueprint, scope) {\n        var _a, _b;\n        if (this.components[key]) {\n            console.error('Component already exists', key);\n        }\n        // if (blueprint == null) {\n        //     return\n        // }\n        if (mix_1.isMixed(blueprint)) {\n            console.error('Component should not be of mixed type');\n            var last = mix_1.lastEffectiveValue(blueprint);\n            if (last === false || last == null) {\n                return;\n            }\n        }\n        else if (exports.isGear(blueprint)) {\n            // FIXME\n            // if (blueprint.parent) {\n            //     // FIXME это надо заменить на removeChild\n            //     blueprint.key ? blueprint.parent.removeKeyed(blueprint.key) : blueprint.parent.removeIndexed(blueprint.index)\n            // }\n            blueprint.parent = this;\n            blueprint.key = key;\n            this.components[key] = blueprint;\n            return blueprint;\n        }\n        var _c = this.options, defaultComponent = _c.defaultComponent, templates = _c.templates, componentFactory = _c.componentFactory;\n        var template = templates ? templates[key] : undefined;\n        //        const templates = this.parent.options.templates\n        var compOpts = mix_1.mixin(defaultComponent, template, blueprint).build(this.initRules());\n        if (compOpts) {\n            //            console.log('addKeyed', key, compOpts)\n            //            console.log(scope)\n            var comp = (componentFactory || this.scope.$defaultFactory)(compOpts, this.scope, scope);\n            comp.key = key;\n            comp.parent = this;\n            this.components[key] = comp;\n            (_b = (_a = this.events).afterAddKeyed) === null || _b === void 0 ? void 0 : _b.call(_a, comp, this.scope);\n            return comp;\n        }\n    };\n    Gear.prototype.removeKeyed = function (key) {\n        var _a, _b;\n        (_b = (_a = this.events).beforeRemoveKeyed) === null || _b === void 0 ? void 0 : _b.call(_a, key, this.scope);\n        delete this.components[key];\n    };\n    Gear.prototype.updateKeyed = function (key, blueprint) {\n        this.components[key].destroy();\n        this.addKeyed(key, blueprint);\n    };\n    Gear.prototype.syncKeyed = function (next) {\n        //        console.log('sync-keyed', this.key, next)\n        var _a;\n        var _b, _c;\n        if (value_1.isIterable(next)) {\n            var it_1 = next;\n            var key = it_1.$name;\n            var components_1 = __assign({}, this.components);\n            var componentsToUpdate_1 = {};\n            var componentsToAdd_1 = {};\n            next.$each(function (result) {\n                var k = result.$uid;\n                if (k in components_1) {\n                    componentsToUpdate_1[k] = components_1[k];\n                }\n                else {\n                    componentsToAdd_1[k] = result;\n                }\n                delete components_1[k];\n            });\n            // let result = it.next()\n            // while (!result.done) {\n            //     const k = result.value.$uid\n            //     if (k in components) {\n            //         componentsToUpdate[k] = components[k]\n            //     }\n            //     else {\n            //         componentsToAdd[k] = result.value\n            //     }\n            //     delete components[k]\n            //     result = it.next()\n            // }\n            for (var k in componentsToAdd_1) {\n                // FIXME не бьются типы скоупа и нового элемента\n                this.addKeyed(k, {}, (_a = {}, _a[key] = componentsToAdd_1[k], _a));\n            }\n            for (var k in components_1) {\n                this.removeKeyed(k);\n            }\n            for (var k in componentsToUpdate_1) {\n                console.warn('Component update not yet ready');\n                // TODO\n            }\n        }\n        else {\n            // свойство аддитивности позволяет обновлять элементы поотдельности\n            for (var k in next) {\n                var nextComp = next[k].build(this.initRules());\n                //                console.log('Next comp', k, nextComp, next[k])\n                var comp = this.components[k];\n                if (nextComp === false) {\n                    if (comp) {\n                        if (comp.parent == this) {\n                            // для собственных компонентов начинаем процедуру удаления\n                            comp.destroy();\n                        }\n                        else {\n                            // компонент-кукушку просто убираем из списка\n                            this.removeKeyed(k);\n                        }\n                    }\n                }\n                else if (nextComp === true) {\n                    if (!comp) {\n                        this.addKeyed(k, {});\n                    }\n                    else if (comp.state == Hub_1.State.Destroying) {\n                        console.log('stop destroying', k);\n                        comp.reset();\n                    }\n                    else {\n                        if (comp.state == Hub_1.State.Destroyed) {\n                            console.warn('component already destroyed', k);\n                        }\n                    }\n                }\n                else if (nextComp != null) {\n                    if (!comp) {\n                        this.addKeyed(k, nextComp);\n                    }\n                    else {\n                        // FIXME здесь мы предполагаем, что в next именно options\n                        comp.reset(nextComp);\n                    }\n                }\n                else {\n                    // игнорируем пустые компоненты\n                }\n            }\n        }\n        (_c = (_b = this.events).afterSyncKeyed) === null || _c === void 0 ? void 0 : _c.call(_b, this.components, this.scope);\n    };\n    //-----------------------\n    // Indexed\n    //-----------------------\n    Gear.prototype.addIndexed = function (blueprint, idx, scope) {\n        if (blueprint == null) {\n            return;\n        }\n        if (mix_1.isMixed(blueprint)) {\n            //            console.error('Item should not be of mixed type')\n            var last = mix_1.lastEffectiveValue(blueprint);\n            if (last === false || last == null) {\n                return;\n            }\n        }\n        else if (exports.isGear(blueprint)) {\n            // FIXME\n            this.items.push(blueprint);\n            return blueprint;\n        }\n        var _a = this.options, defaultItem = _a.defaultItem, itemFactory = _a.itemFactory;\n        //const template = templates ? templates[templateKey] : undefined\n        var itemOpts = mix_1.mixin(defaultItem /*, template*/, blueprint).build(this.initRules());\n        //        console.log(itemOpts)\n        if (itemOpts) {\n            var index = idx;\n            if (index == null) {\n                index = this.items.length;\n            }\n            else {\n                for (var i = index; i < this.items.length; i++) {\n                    this.items[i].index++;\n                }\n            }\n            var item = (itemFactory || this.scope.$defaultFactory)(itemOpts, this.scope, scope);\n            item.index = index;\n            item.parent = this;\n            this.items.splice(index, 0, item);\n            return item;\n        }\n    };\n    Gear.prototype.updateIndexed = function (idx, blueprint) {\n        // TODO\n    };\n    Gear.prototype.removeIndexed = function (idx) {\n        this.items.splice(idx, 1);\n        this.items.forEach(function (itm) {\n            if (itm.index > idx) {\n                itm.index--;\n            }\n        });\n    };\n    Gear.prototype.syncIndexed = function (next) {\n        //        console.log('sync indexed', this.key, next)\n        var _this = this;\n        var _a, _b;\n        if (value_1.isIterable(next)) {\n            var it_2 = next;\n            var key_1 = it_2.$name;\n            //            console.log('iterable', key, it)\n            var prevItems_1 = [];\n            this.items.forEach(function (item) {\n                prevItems_1.push({\n                    key: String(item.uid),\n                    value: item\n                });\n            });\n            var nextItems_1 = [];\n            next.$each(function (result, key) {\n                nextItems_1.push({\n                    key: result.$uid === undefined ? key : result.$uid,\n                    value: result\n                });\n            });\n            // let result = it.next()\n            // while (!result.done) {\n            //     nextItems.push({\n            //         key: result.value.$uid,\n            //         value: result.value\n            //     })\n            //     result = it.next()\n            // }\n            //            console.log('next items', nextItems, prevItems)\n            //            console.log('reconcile')\n            var mergedItems = reconcile_1.reconcile(prevItems_1, nextItems_1);\n            //            console.log('reconcile end')\n            //            console.log('merged items', this.key, mergedItems)\n            var children_1 = [];\n            var i_1 = 0;\n            mergedItems.forEach(function (itm) {\n                var _a;\n                var item = null;\n                if (itm.op == reconcile_1.ItemOp.ADD) {\n                    var v = itm.value;\n                    item = _this.addIndexed({}, i_1, key_1 ? (_a = {}, _a[key_1] = v, _a) : v);\n                    item.uid = itm.key; // v.$uid\n                    //                        console.log('add', i, itm.key)//v.$uid)\n                }\n                else if (itm.op == reconcile_1.ItemOp.DELETE) {\n                    item = itm.value;\n                    item.parent = null;\n                    item.destroy();\n                    item.parent = _this;\n                    if (item.state == Hub_1.State.Destroyed) {\n                        i_1--;\n                        item = null;\n                    }\n                    // else {\n                    //     debugger\n                    // }\n                    //                        console.log('del', i, itm.key)\n                }\n                else {\n                    item = itm.value;\n                    item.index = i_1;\n                    //                        console.log('upd', i, itm.key, itm.value)\n                }\n                item && children_1.push(item);\n                i_1++;\n            });\n            this.items = children_1;\n            //            console.log(this.items)\n        }\n        else {\n            //            console.log(next)\n            if (!Array.isArray(next)) {\n                console.error('Items must be array like value', next);\n            }\n            // у индексированных элементов нет свойства аддитивности, поэтому пересоздаем все элементы\n            this.items.forEach(function (item) {\n                delete item.parent;\n                item.destroy();\n            });\n            this.items = [];\n            for (var _i = 0, next_1 = next; _i < next_1.length; _i++) {\n                var o = next_1[_i];\n                this.addIndexed(o);\n            }\n        }\n        (_b = (_a = this.events).afterSyncIndexed) === null || _b === void 0 ? void 0 : _b.call(_a, this.items, this.scope);\n    };\n    Gear.prototype.destroy = function (deferred) {\n        var _this = this;\n        _super.prototype.destroy.call(this, function () {\n            deferred && deferred();\n            if (_this.parent) {\n                if (_this.key) {\n                    _this.parent.removeKeyed(_this.key);\n                }\n                else {\n                    _this.parent.removeIndexed(_this.index);\n                }\n            }\n            for (var _i = 0, _a = _this.items; _i < _a.length; _i++) {\n                var child = _a[_i];\n                delete child.parent;\n                child.destroy();\n            }\n            for (var k in _this.components) {\n                var child = _this.components[k];\n                delete child.parent;\n                child.destroy();\n            }\n            delete _this.parent;\n            delete _this.key;\n            delete _this.index;\n            _this.items = [];\n            _this.components = {};\n        });\n    };\n    Object.defineProperty(Gear.prototype, \"children\", {\n        get: function () {\n            var _this = this;\n            var children = [].concat(this.items).concat(Object.values(this.components)).filter(function (c) { return c.parent == _this; });\n            if (this.options.childFilter) {\n                children = children.filter(this.options.childFilter);\n            }\n            return children.sort(this.options.childSorter || defaultGearSort);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Gear.prototype.visit = function (visitor) {\n        if (visitor(this) !== false) {\n            this.children.forEach(visitor);\n        }\n    };\n    return Gear;\n}(Hub_1.Hub));\nexports.Gear = Gear;\n//# sourceMappingURL=Gear.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Html = exports.defaultLayout = exports.passthruLayout = exports.defaultRender = exports.defaultHtmlFactory = exports.defaultHtmlPatchRules = exports.defaultHtmlInitRules = void 0;\nvar _1 = require(\".\");\nvar Gear_1 = require(\"./Gear\");\nvar render_1 = require(\"./render\");\nvar rules_1 = require(\"./rules\");\nexports.defaultHtmlInitRules = __assign({ css: rules_1.DefaultRules.StringArray }, Gear_1.defaultInitRules);\nexports.defaultHtmlPatchRules = __assign({ css: rules_1.DefaultRules.StringArray }, Gear_1.defaultPatchRules);\nvar defaultHtmlFactory = function (opts, context, scope, rules) {\n    return new Html(opts, context, scope);\n};\nexports.defaultHtmlFactory = defaultHtmlFactory;\nvar defaultRender = function (html) { return (html.render) ? html.render() : html; };\nexports.defaultRender = defaultRender;\nvar passthruLayout = function (factory, key, props, dom, children) {\n    return children && children.map(exports.defaultRender);\n};\nexports.passthruLayout = passthruLayout;\nvar defaultLayout = function (factory, key, props, dom, children) {\n    return factory.createVNode(key, props, dom, children && children.map(exports.defaultRender));\n};\nexports.defaultLayout = defaultLayout;\nvar Html = /** @class */ (function (_super) {\n    __extends(Html, _super);\n    //    ext: HtmlProps\n    function Html(options, context, scope) {\n        var _this = _super.call(this, options, context, scope) || this;\n        _this.scope.$dom = new render_1.DomNode(_this.scope.$renderer);\n        return _this;\n        //        this.ext = {}\n        //        this.dirty = true\n    }\n    Html.prototype.patch = function (optPatch) {\n        _super.prototype.patch.call(this, optPatch);\n        var o = this.options;\n        // TODO\n        var dom = this.scope.$dom;\n        if (optPatch.classes) {\n            dom.className = render_1.buildClassName(dom.className, o.classes);\n        }\n        if (optPatch.css) {\n            dom.className = render_1.buildClassName(dom.className, o.css);\n        }\n        if (optPatch.styles) {\n            dom.styles = __assign(__assign({}, dom.styles), o.styles);\n        }\n        if (optPatch.html) {\n            dom.html = o.html;\n        }\n        if (optPatch.tag != null) {\n            dom.tag = o.tag;\n        }\n        // помечаем путь до корня \"грязным\"\n        var html = this;\n        while (html && !html.dirty) {\n            html.dirty = true;\n            //            if (!html.parent) {\n            if (html.isRoot) {\n                //                debugger\n                // планируем перерисовку в свой такт (после всех патчей)\n                html.scope.$pipe.push(html.scope.$renderer.task(null));\n                //                break\n            }\n            html = html.parent;\n        }\n        // this.visit((h) => {\n        //     if (h.dirty) return false\n        //     h.dirty = true\n        // })\n    };\n    Html.prototype.initRules = function () {\n        return exports.defaultHtmlInitRules;\n    };\n    Html.prototype.patchRules = function () {\n        return exports.defaultHtmlPatchRules;\n    };\n    Html.prototype.attach = function (root) {\n        this.scope.$renderer.attach(root, this);\n        this.attached = true;\n    };\n    Html.prototype.detach = function () {\n        this.scope.$renderer.detach(this);\n        this.attached = false;\n    };\n    Object.defineProperty(Html.prototype, \"isRoot\", {\n        get: function () {\n            return this.parent ? (this.parent.scope.$renderer != this.scope.$renderer) : true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Html.prototype.render = function (asRoot) {\n        if (this.state == _1.State.Destroyed) {\n            return null;\n        }\n        if (!asRoot && this.isRoot) {\n            return null;\n        }\n        if (this.options.render === false) {\n            return null;\n        }\n        if (!this.dirty) {\n            return this.vnode;\n        }\n        var o = this.options;\n        var layout = o.layout || this.scope.$defaultLayout;\n        //        const renderer: Renderer = this.scope.$renderer\n        var factory = this.scope.$renderer; //.$vnodeFactory\n        var dom = this.scope.$dom;\n        var text = o.text;\n        var children = this.children;\n        var key = this.uid || this.key || this.index;\n        // if (key != null) {\n        //     ext.key = key\n        // }\n        if (text || children.length > 0) {\n            var childrenAndText = children;\n            if (text) {\n                childrenAndText = __spreadArray([], children);\n                var i = children.findIndex(function (c) { return c.options.weight && c.options.weight > 0; });\n                if (i == -1) {\n                    childrenAndText.push(text);\n                }\n                else {\n                    childrenAndText.splice(i, 0, text);\n                }\n            }\n            this.vnode = layout(factory, key, this.options.dom, dom, childrenAndText);\n        }\n        else {\n            this.vnode = layout(factory, key, this.options.dom, dom);\n        }\n        //        (dom as any).$applyEffects(this.scope.$renderer)\n        this.dirty = false;\n        return this.vnode;\n    };\n    Html.prototype.destroy = function (defer) {\n        var _this = this;\n        _super.prototype.destroy.call(this, function () {\n            if (_this.attached) {\n                _this.detach();\n            }\n            else {\n                // помечаем путь до корня \"грязным\"\n                var html = _this;\n                while (html && !html.dirty) {\n                    html.dirty = true;\n                    //            if (!html.parent) {\n                    if (html.isRoot) {\n                        if (_this.state == _1.State.Destroying) {\n                            // отложенное удаление планируем в ближайший кадр, чтобы удаленный элемент как можно скорее пропал из VDOM\n                            html.scope.$renderer.publish(html.scope.$renderer.task(null));\n                        }\n                        else {\n                            // немедленное удаление синхронизируем с патчами, чтобы избежать \"моргания\"\n                            html.scope.$engine.publish(html.scope.$renderer.task(null));\n                        }\n                        //                debugger\n                        //                break\n                    }\n                    html = html.parent;\n                }\n            }\n            defer && defer();\n        });\n    };\n    return Html;\n}(Gear_1.Gear));\nexports.Html = Html;\n//# sourceMappingURL=Html.js.map","\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hub = exports.patch = exports.State = void 0;\nvar value_1 = require(\"./value\");\nvar mix_1 = require(\"./mix\");\nvar pipe_1 = require(\"./pipe\");\nvar State;\n(function (State) {\n    State[State[\"Initializing\"] = 0] = \"Initializing\";\n    State[State[\"Initialized\"] = 1] = \"Initialized\";\n    State[State[\"Destroying\"] = 2] = \"Destroying\";\n    State[State[\"Destroyed\"] = 3] = \"Destroyed\";\n})(State = exports.State || (exports.State = {}));\nvar _PatchingHub = undefined;\nvar patch = function (o) {\n    _PatchingHub.scope.$engine.publish(pipe_1.ownTask(_PatchingHub.patch, o, _PatchingHub));\n    //_PatchingHub.scope.$pipe.push(ownTask(_PatchingHub.patch, o, _PatchingHub))\n};\nexports.patch = patch;\nvar _ScopeKey;\nvar scopeKeyAware = function (key, fn) {\n    var prevScopeKey = _ScopeKey;\n    _ScopeKey = key;\n    fn();\n    _ScopeKey = prevScopeKey;\n};\nvar createMonitoredThenable = function (thenable) {\n    var monitored = thenable.then(function (v) {\n        mt.isDone = true;\n        mt.isPending = false;\n        return v;\n    }, function (v) {\n        mt.isFailed = true;\n        mt.isPending = false;\n        return v;\n    });\n    var mt = {\n        isPending: true,\n        isFailed: false,\n        isDone: false,\n        then: function (resolve, reject) { return monitored.then(resolve, reject); }\n    };\n    return mt;\n};\nvar isMonitoredThenable = function (v) {\n    return v.then != null;\n};\n// export const _iterator = <T extends []|{}>(source: T) : ValueIterator<T> => {\n//     if (_ScopeKey == null) {\n//         console.warn('Scope key not detected')\n//     }\n//     return iterator(source, String(_ScopeKey))\n// }\n// export const _next = <T extends {}|[], K extends keyof T=keyof T>(value: Value<T>) : T[K] => {\n//     if (_ScopeKey == null) {\n//         console.warn('Scope key not detected')\n//     }\n//     return value as any\n// }\nvar Hub = /** @class */ (function () {\n    //    _context: any\n    // initialized: boolean\n    // destroyed: boolean\n    //    _Injectors: Injectors<any> = null\n    function Hub(options, context, initScope) {\n        var _this = this;\n        if (context === void 0) { context = null; }\n        if (initScope === void 0) { initScope = null; }\n        this.options = {};\n        //        this.context = context\n        //        this.scope = Object.assign({}, context as any)\n        this._local = {};\n        //        this._context = {...context}\n        //let _InjectProp: string|symbol = null\n        var _InjectProps = {};\n        var PropState;\n        (function (PropState) {\n            PropState[PropState[\"None\"] = 0] = \"None\";\n            PropState[PropState[\"Injector\"] = 1] = \"Injector\";\n            PropState[PropState[\"Initial\"] = 2] = \"Initial\";\n            PropState[PropState[\"Default\"] = 3] = \"Default\";\n            PropState[PropState[\"Context\"] = 4] = \"Context\";\n        })(PropState || (PropState = {}));\n        // injector -> initial -> default -> context\n        this.scope = new Proxy(this._local, {\n            get: function (target, p) {\n                if (p == '$context') {\n                    return context;\n                }\n                //                console.log('get', p)\n                var isInjected = false;\n                var prop = _InjectProps[String(p)] || PropState.None;\n                var prevPropState = _InjectProps[String(p)];\n                var prevProp = target[p];\n                //                if () {\n                if ( /*!isInjected && this.state != State.Initializing &&*/(p in target)) {\n                    isInjected = true;\n                    //                        return (target[p] && isAutoTerminal() && target[p].$isTerminal) ? target[p].$value : target[p]\n                }\n                // if (this.state == State.Initializing) {\n                //     isInjected = false\n                //     prop = PropState.None\n                //     target[p] = undefined\n                // }\n                // if (this.options.injections && (this.options.injections as any)['$engine']) {\n                //     console.log('$engine', p, isInjected, prop)\n                // }\n                if (!isInjected && prop < PropState.Injector && _this.options.injections) {\n                    var injector_1 = _this.options.injections[p];\n                    if (injector_1 !== undefined) {\n                        if (typeof injector_1 === 'function') {\n                            _InjectProps[String(p)] = PropState.Injector;\n                            scopeKeyAware(p, function () {\n                                value_1.noAutoTerminal(function () {\n                                    // const entry = injector(this.scope)\n                                    // if (entry !== undefined) {\n                                    //     target[p] = entry\n                                    // }\n                                    target[p] = injector_1(_this.scope);\n                                });\n                            });\n                        }\n                        else if (injector_1 != null) {\n                            console.warn('Injector must be a function', p, injector_1);\n                            return;\n                        }\n                        isInjected = true;\n                        //                            return target[p]\n                    }\n                }\n                //                }\n                if (!isInjected && prop < PropState.Initial && initScope) {\n                    //                    console.log('--- check initial ---', p)\n                    var hasProp = false;\n                    if (value_1.isValueSet(initScope)) {\n                        hasProp = initScope.$has(p) && initScope.$at(p).$value != null;\n                    }\n                    else if (initScope[p] != null) {\n                        hasProp = true;\n                    }\n                    if (hasProp) {\n                        _InjectProps[String(p)] = PropState.Initial;\n                        target[p] = initScope[p];\n                        isInjected = true;\n                    }\n                }\n                if (!isInjected && prop < PropState.Default && _this.options.initials) {\n                    var injector_2 = _this.options.initials[p];\n                    if (injector_2 !== undefined) {\n                        if (typeof injector_2 === 'function') {\n                            _InjectProps[String(p)] = PropState.Default;\n                            scopeKeyAware(p, function () {\n                                value_1.noAutoTerminal(function () {\n                                    target[p] = injector_2(_this.scope);\n                                });\n                            });\n                        }\n                        else if (injector_2 != null) {\n                            console.warn('Injector must be a function', p, injector_2);\n                            return;\n                        }\n                        isInjected = true;\n                        //                        return target[p]\n                    }\n                }\n                if (!isInjected && prop < PropState.Context) {\n                    _InjectProps[String(p)] = PropState.Context;\n                    value_1.noAutoTerminal(function () {\n                        target[p] = context[p];\n                    });\n                    isInjected = true;\n                    // if (this.state == State.Initializing) {\n                    //     isInjected = false\n                    //     //_InjectProps[String(p)] = PropState.None\n                    // }\n                }\n                if (_this.state == State.Initializing && (p == '$engine' || p == '$renderer' || p == '$pipe')) {\n                    var out = (target[p] && value_1.isAutoTerminal() && target[p].$isTerminal) ? target[p].$value : target[p];\n                    delete target[p];\n                    _InjectProps[String(p)] = PropState.None;\n                    isInjected = false;\n                    return out;\n                }\n                //                return target[p]\n                return (target[p] && value_1.isAutoTerminal() && target[p].$isTerminal) ? target[p].$value : target[p];\n            },\n            set: function (target, p, value) {\n                // if (p == 'current') {\n                //     debugger\n                // }\n                //                console.log('set scope value', p, value, p in target)\n                // FIXME заменить на инжектирование\n                if (!(p in target)) {\n                    target[p] = _this.scope[String(p)]; // неявно инжектируем\n                }\n                // isObservable\n                if (target[p] != null && (typeof target[p].$at === 'function')) {\n                    target[p].$value = value;\n                }\n                else {\n                    //                    console.error('Inject not an observable into scope', p, value)\n                    target[p] = value;\n                }\n                return true;\n            },\n            has: function (target, p) {\n                return Reflect.has(target, p) || Reflect.has(context, p) || (_this.options.injections && Reflect.has(_this.options.injections, p));\n            },\n            ownKeys: function (target) {\n                var keys = __assign(__assign(__assign({}, context), target), _this.options.injections);\n                return Object.keys(keys);\n            },\n            getOwnPropertyDescriptor: function (target, p) {\n                return Reflect.getOwnPropertyDescriptor(target, p)\n                    || Reflect.getOwnPropertyDescriptor(context, p)\n                    || (_this.options.injections && Reflect.getOwnPropertyDescriptor(_this.options.injections, p));\n            },\n        });\n        this.subscriptions = [];\n        this.handlers = [];\n        this.events = {};\n        this.bindings = {};\n        this.joints = [];\n        this.state = State.Initializing;\n        // добавляем патч в очередь задач\n        this.scope.$engine.publish(pipe_1.ownTask(this.patch, options, this));\n    }\n    Hub.prototype.patch = function (optPatch) {\n        var _this = this;\n        var _a, _b;\n        if (this.state == State.Destroying || this.state == State.Destroyed) {\n            //            console.error('Try to patch destroyed hub')\n            throw new Error('Try to patch destroyed object');\n        }\n        var opts = mix_1.mixin(this.options, optPatch).build(this.state == State.Initialized ? this.patchRules() : this.initRules());\n        if (opts === true || opts === false) {\n            throw new Error('Invalid patch option mix');\n        }\n        //        console.log(this.options, optPatch)\n        var o = this.options = opts;\n        var newSubscriptions = [];\n        var newHandlers = [];\n        // // Injectors\n        // if (optPatch.injections) {\n        //     // здесь мы должны обновлять измененные инжекторы\n        //     // this._Injectors = o.injections\n        //     // for (let k in o.injections) {\n        //     //     this.scope[k]\n        //     //     // const injector: Injector<any> = o.injections[k]\n        //     //     // if (injector !== undefined) {\n        //     //     //     let entry = null\n        //     //     //     if (typeof injector === 'function') {\n        //     //     //         entry = injector(this.scope)\n        //     //     //     }\n        //     //     //     else if (injector != null) {\n        //     //     //         console.warn('Injector must be a function', k, injector)\n        //     //     //         continue\n        //     //     //     }\n        //     //     //     if (this.scope[k] != entry) {\n        //     //     //         // TODO здесь нужно отписываться от элемента скоупа \n        //     //     //         this.scope[k] = entry\n        //     //     //     }\n        //     //     // }\n        //     // }\n        //     // this._Injectors = null\n        // }\n        // Joints\n        //TODO joints не должны обновляться динамически, но все равно нужно сделать обработку\n        if (optPatch.joints) {\n            var subscriptions = value_1.spySubscriptions(function () {\n                value_1.noAutoTerminal(function () {\n                    for (var k in o.joints) {\n                        var joint = o.joints[k].call(_this, _this.scope);\n                        if (joint && joint.then) {\n                            joint = createMonitoredThenable(joint);\n                        }\n                        _this.joints.push(joint);\n                        // for (let i in o.joints[k]) {\n                        //     if (o.joints[k][i]) {\n                        //         const joint = o.joints[k][i].call(this, this.scope[k], this.scope)\n                        //         this.joints.push(joint)    \n                        //     }\n                        // }\n                    }\n                });\n            });\n            newSubscriptions = newSubscriptions.concat(subscriptions);\n        }\n        // Reactors\n        if (optPatch.reactions) {\n            var _loop_1 = function (k) {\n                if (o.reactions[k] && !this_1.bindings[k]) {\n                    this_1.bindings[k] = this_1.patchAware(o.reactions[k]); //scopeKeyAware.bind(this, k, this.patchAware(o.reactions[k])) \n                    var entry_1 = this_1.scope[k];\n                    var binding_1 = this_1.bindings[k];\n                    if (value_1.isObservable(entry_1)) {\n                        var sub = entry_1.$subscribe(function (next, prev) {\n                            value_1.autoTerminalAware(function () {\n                                scopeKeyAware(k, function () {\n                                    binding_1(entry_1.$isTerminal ? next : entry_1, prev);\n                                });\n                            });\n                        });\n                        newSubscriptions.push(sub);\n                    }\n                    else {\n                        binding_1(entry_1, undefined);\n                    }\n                }\n            };\n            var this_1 = this;\n            for (var k in o.reactions) {\n                _loop_1(k);\n            }\n        }\n        // Events\n        if (optPatch.events) {\n            var _loop_2 = function (i) {\n                if (o.events[i] && !this_2.events[i]) {\n                    this_2.events[i] = o.events[i]; // FIXME\n                    var _loop_3 = function (k) {\n                        var bus = this_2.scope[k];\n                        var callback = this_2.events[i];\n                        if (value_1.isEventBus(bus) && bus.$hasEvent(i)) {\n                            var handler = bus.$on(i, function (evt) {\n                                value_1.noAutoTerminal(function () {\n                                    callback(evt, _this.scope);\n                                });\n                            }, this_2);\n                            newHandlers.push(handler); // FIXME\n                        }\n                    };\n                    for (var k in this_2.scope) {\n                        _loop_3(k);\n                    }\n                    var events = o.events[i];\n                    if (typeof events === 'function') {\n                        if (value_1.isCallable(this_2.scope[i])) {\n                            var bus = this_2.scope[i];\n                            var callback_1 = events;\n                            var handler = bus.$on('done', function () {\n                                var args = [];\n                                for (var _i = 0; _i < arguments.length; _i++) {\n                                    args[_i] = arguments[_i];\n                                }\n                                value_1.noAutoTerminal(function () {\n                                    callback_1.apply(null, __spreadArray(__spreadArray([], args), [_this.scope]));\n                                });\n                            }, this_2);\n                            newHandlers.push(handler); // FIXME\n                        }\n                    }\n                    else if (typeof events === 'object') {\n                        var bus = this_2.scope[i];\n                        var _loop_4 = function (k) {\n                            // FIXME добавить регистрацию событий\n                            var callback = events[k];\n                            if (callback && value_1.isEventBus(bus) /*&& bus.$hasEvent(i)*/) {\n                                var handler = bus.$on(k, function () {\n                                    var args = [];\n                                    for (var _i = 0; _i < arguments.length; _i++) {\n                                        args[_i] = arguments[_i];\n                                    }\n                                    value_1.noAutoTerminal(function () {\n                                        callback.apply(null, __spreadArray(__spreadArray([], args), [_this.scope]));\n                                    });\n                                }, this_2);\n                                newHandlers.push(handler); // FIXME\n                            }\n                        };\n                        for (var k in events) {\n                            _loop_4(k);\n                        }\n                    }\n                }\n            };\n            var this_2 = this;\n            for (var i in o.events) {\n                _loop_2(i);\n            }\n        }\n        // освежаем реакции\n        //        noAutoTerminal(() => {\n        // if (newSubscriptions.length) {\n        //     console.log('new subscriptions', newSubscriptions)\n        // }\n        for (var _i = 0, newSubscriptions_1 = newSubscriptions; _i < newSubscriptions_1.length; _i++) {\n            var sub = newSubscriptions_1[_i];\n            if (sub == null) {\n                console.error('Undefined subscription');\n            }\n            else {\n                sub.observable.$touch(sub.subscriber);\n            }\n        }\n        //        })\n        // TODO предполагается, что повторов подписок нет\n        this.subscriptions = this.subscriptions.concat(newSubscriptions);\n        this.handlers = this.handlers.concat(newHandlers);\n        if (this.state == State.Initializing) {\n            this.state = State.Initialized;\n            (_b = (_a = this.events).afterInit) === null || _b === void 0 ? void 0 : _b.call(_a, this, this.scope);\n        }\n        // if (this.events['patch']) {\n        //     this.events['patch'](this.options, this.scope)\n        // }\n    };\n    Hub.prototype.destroy = function (deferred) {\n        var _this = this;\n        // исключаем повторное удаление\n        if (this.state == State.Destroying || this.state == State.Destroyed) {\n            return;\n        }\n        // обрабатываем хуки отключения скоупа\n        var disjointPromise = null;\n        if (this.joints.length > 0) {\n            var promises = [];\n            for (var _i = 0, _a = this.joints; _i < _a.length; _i++) {\n                var disjoint = _a[_i];\n                if (disjoint) {\n                    if (isMonitoredThenable(disjoint)) {\n                        debugger;\n                        disjoint.isPending && promises.push(disjoint);\n                    }\n                    else if (typeof disjoint === 'function') {\n                        var eff = disjoint();\n                        if (eff && eff.then) {\n                            promises.push(eff);\n                        }\n                    }\n                }\n            }\n            this.joints = [];\n            if (promises.length > 0) {\n                disjointPromise = Promise.all(promises);\n            }\n        }\n        // удаляем подписки на изменения\n        for (var _b = 0, _c = this.subscriptions; _b < _c.length; _b++) {\n            var sub = _c[_b];\n            if (sub == null) {\n                console.error('Undefined subscription');\n            }\n            else {\n                sub.observable.$unsubscribe(sub);\n            }\n        }\n        // удаляем подписки на события\n        for (var _d = 0, _e = this.handlers; _d < _e.length; _d++) {\n            var h = _e[_d];\n            h.bus.$off(h);\n        }\n        //        this.bindings = {}\n        this.events = {};\n        //        this.subscriptions = []\n        this.handlers = [];\n        if (disjointPromise) {\n            this.state = State.Destroying;\n            disjointPromise.then(function () {\n                // завершаем удаление, только если статус на удалении\n                if (_this.state == State.Destroying) {\n                    deferred && deferred();\n                    _this.scope = null;\n                    _this.state = State.Destroyed;\n                    console.log('Delayed destroy done');\n                }\n            }, function (err) {\n                console.log('Delayed destroy fail', err);\n            });\n        }\n        else {\n            deferred && deferred();\n            this.scope = null;\n            this.state = State.Destroyed;\n        }\n        // // отложенное удаление\n        // if (promise) {\n        //     this.state = State.Destroying\n        //     promise.then(() => {\n        //         // продолжаем удаление, если оно не отменено\n        //         if (this.state == State.Destroying) {\n        //             //this.state = State.Initialized // ?\n        //             this.destroy()\n        //             //this.scope.$engine.immediate(this) // ?\n        //         }\n        //      }, (err) => {\n        //         console.log('Delayed destroy fail', err)\n        //      })\n        //     return\n        // }\n        // if (disjointPromise) {\n        //     this.state = State.Destroying\n        //     disjointPromise.then(() => {\n        //         // продолжаем удаление, если оно не отменено\n        //         // if (this.state == State.Destroying) {\n        //         //     //this.state = State.Initialized // ?\n        //         //     this.destroy()\n        //         //     //this.scope.$engine.immediate(this) // ?\n        //         // }\n        //      }, (err) => {\n        //         console.log('Delayed destroy fail', err)\n        //      })            \n        // }\n        // else {\n        //     this.state = State.Destroyed\n        // }\n    };\n    Hub.prototype.patchAware = function (callback) {\n        var _this = this;\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var prevPatchingTarget = _PatchingHub;\n            _PatchingHub = _this;\n            callback.apply(_this, args);\n            _PatchingHub = prevPatchingTarget;\n        };\n    };\n    // emit (name: string, event: any) {\n    //     this.events[name](event, this.scope)\n    // }\n    Hub.prototype.initRules = function () {\n        return {};\n    };\n    Hub.prototype.patchRules = function () {\n        return {};\n    };\n    Hub.prototype.reset = function (nextOpts) {\n        this.state = State.Initializing;\n        if (nextOpts != null) {\n            console.warn('component update not yet ready', nextOpts, this);\n            this.patch(nextOpts);\n            return;\n        }\n        // FIXME возможно, необходимо сначала почистить хаб\n        this.patch(this.options);\n    };\n    return Hub;\n}());\nexports.Hub = Hub;\n//# sourceMappingURL=Hub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./Hub\"), exports);\n__exportStar(require(\"./Html\"), exports);\n__exportStar(require(\"./Gear\"), exports);\n__exportStar(require(\"./Hub\"), exports);\n__exportStar(require(\"./Blueprint\"), exports);\n__exportStar(require(\"./value\"), exports);\n__exportStar(require(\"./engine\"), exports);\n__exportStar(require(\"./render\"), exports);\n__exportStar(require(\"./mix\"), exports);\n__exportStar(require(\"./pipe\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isMixed = exports.mixin = exports.lastEffectiveValue = exports.Mixin = void 0;\nvar value_1 = require(\"../value\");\nvar utils_1 = require(\"./utils\");\nvar Mixin = /** @class */ (function () {\n    function Mixin() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._raw = [];\n        for (var i = 0; i < args.length; i++) {\n            this.mix(args[i]); //FIXME  потенциальная потеря производительности\n        }\n    }\n    Mixin.prototype.mixins = function () {\n        return this._raw;\n    };\n    Mixin.prototype.mix = function (nextOpts) {\n        if (nextOpts != null) {\n            if (typeof nextOpts.mixins === 'function') {\n                //                console.log(nextOpts.mixins())\n                this._raw = this._raw.concat(nextOpts.mixins()); //(nextOpts as any)._raw)\n            }\n            else {\n                this._raw.push(nextOpts);\n            }\n        }\n        return this;\n    };\n    Mixin.prototype.mergeBefore = function (prevOpts) {\n        if (prevOpts != null) {\n            if (prevOpts.mix !== undefined) {\n                debugger;\n                this._raw = prevOpts._raw.concat(this._raw);\n            }\n            else {\n                this._raw.unshift(prevOpts);\n            }\n        }\n        return this;\n    };\n    Mixin.prototype.build = function (rules) {\n        if (this._raw.length == 0) {\n            return undefined;\n        }\n        // немножко эвристики для кейсов, когда опции отключаются последним сегментом\n        if (this._raw[this._raw.length - 1] === false) {\n            return false;\n        }\n        if (this._raw[0] === true && this._raw.length == 1) {\n            return true;\n        }\n        var o = {};\n        var clear = false;\n        for (var i = 0; i < this._raw.length; i++) {\n            if (this._raw[i] === true) {\n                clear = false;\n                //        continue\n            }\n            else if (this._raw[i] === false) {\n                clear = true;\n                //        continue\n            }\n            else {\n                if (clear) {\n                    o = {};\n                }\n                o = utils_1.buildOpts(o, this._raw[i], rules);\n                clear = false;\n            }\n        }\n        return clear ? {} : o;\n    };\n    Object.defineProperty(Mixin.prototype, \"entries\", {\n        get: function () {\n            return this._raw;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Mixin;\n}());\nexports.Mixin = Mixin;\nvar lastEffectiveValue = function (o) {\n    var last = undefined;\n    for (var _i = 0, _a = o.entries; _i < _a.length; _i++) {\n        var value = _a[_i];\n        if (value === true || value === false) {\n            last = (last === !value || last == null) ? value : last;\n        }\n        else if (value != null) {\n            last = value;\n        }\n    }\n    return last;\n};\nexports.lastEffectiveValue = lastEffectiveValue;\nvar mixin = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return new (Function.prototype.bind.apply(Mixin, __spreadArray([null], args)));\n};\nexports.mixin = mixin;\nvar isMixed = function (obj) {\n    if (obj) {\n        if (false && obj[value_1.__isProxy]) {\n            return ('mix' in obj);\n        }\n        else {\n            return typeof obj.mix === 'function';\n        }\n    }\n    return false;\n    //    return !!(obj && (obj as Mixed<T>).mix)\n};\nexports.isMixed = isMixed;\n//# sourceMappingURL=Mixin.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./Mixin\"), exports);\n__exportStar(require(\"./utils\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildOpts = exports.deepClone = void 0;\nvar value_1 = require(\"../value\");\nvar deepClone = function (o) {\n    if (o != null) {\n        if (o.constructor === Object) {\n            var copy = {};\n            for (var i in o) {\n                copy[i] = exports.deepClone(o[i]);\n            }\n            o = copy;\n        }\n        else if (o instanceof Array) {\n            var copy = [];\n            for (var i = 0; i < o.length; i++) {\n                copy[i] = exports.deepClone(o[i]);\n            }\n            o = copy;\n        }\n    }\n    return o;\n    //  return JSON.parse(JSON.stringify(o))\n};\nexports.deepClone = deepClone;\nvar buildProp = function (prop, nextProp, rule) {\n    if (nextProp && value_1.isValueSet(nextProp)) {\n        nextProp = nextProp.$value;\n    }\n    if (rule) {\n        prop = rule(prop, nextProp);\n    }\n    else {\n        if (prop && nextProp !== undefined && (prop.constructor === Object || prop.constructor === Array)) {\n            prop = exports.buildOpts(prop, nextProp);\n        }\n        else if (nextProp !== undefined) {\n            if (nextProp != null && (nextProp.constructor === Object || nextProp.constructor === Array)) {\n                prop = exports.deepClone(nextProp);\n                //        console.log('deep', nextProp, prop)\n            }\n            else {\n                prop = nextProp;\n            }\n        }\n    }\n    return prop;\n};\nvar buildOpts = function (opts, nextOpts, rules) {\n    if (nextOpts && value_1.isValueSet(nextOpts)) {\n        console.warn('Resolve observable opts', nextOpts);\n        nextOpts = nextOpts.$value;\n    }\n    if (typeof nextOpts == 'function') {\n        //    console.log('resolve func mix', nextOpts, opts)\n        nextOpts = nextOpts();\n    }\n    else if (typeof nextOpts == 'string') {\n        console.warn('string opts', nextOpts);\n    }\n    else if (typeof nextOpts == 'number') {\n        console.warn('number opts', nextOpts);\n    }\n    // TODO возможно, здесь нужен цикл до тех пор, пока не исчезнет примесь\n    if (nextOpts && typeof nextOpts.mix === 'function' /*isMixed(nextOpts)*/) {\n        nextOpts = nextOpts.build(rules);\n    }\n    // если nextOpts является объектом\n    if (nextOpts === undefined) {\n        // \n    }\n    else if (nextOpts === null) {\n        opts = null;\n    }\n    else if (nextOpts.constructor === Object) {\n        for (var i in nextOpts) {\n            // if (i[0] == '!') {\n            //   opts[i.substr(1)] = nextOpts[i]\n            // }\n            // else if (i[0] == '+') {\n            //   // TODO\n            // }\n            // else if (i[0] == '-') {\n            //   // TODO\n            // }\n            // else {\n            opts[i] = buildProp(opts[i], nextOpts[i], rules && (rules[i] || rules[i[0]]));\n            // }\n        }\n    }\n    // если nextOpts является массивом\n    else if (nextOpts.constructor === Array) {\n        for (var i = 0; i < nextOpts.length; i++) {\n            opts[i] = buildProp(opts[i], nextOpts[i], rules && (rules[i] /* || rules[i[0]]*/));\n        }\n    }\n    else if (nextOpts instanceof Promise) {\n        return Promise.all([opts, nextOpts]).then(function (o) {\n            return exports.buildOpts(o[0], o[1], rules);\n        });\n    }\n    else { //if (nextOpts !== undefined) {\n        opts = nextOpts;\n    }\n    return opts;\n};\nexports.buildOpts = buildOpts;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncEngine = void 0;\nvar utils_1 = require(\"./utils\");\nvar avgTimeInterval = function (t0, t1, total) {\n    return Number((Math.round(t1 - t0) / total).toFixed(5));\n};\nvar AsyncEngine = /** @class */ (function () {\n    function AsyncEngine(name) {\n        this.tasks = [];\n        this.subscriptions = [];\n        this.deferred = [];\n        this.scheduled = false;\n        this.name = name || 'default';\n    }\n    AsyncEngine.prototype.publish = function (task) {\n        if (task.done) {\n            return;\n        }\n        this.tasks.push(task);\n        !this.scheduled && this.schedule();\n    };\n    AsyncEngine.prototype.subscribe = function (engine) {\n        if (this.subscriptions.indexOf(engine) == -1) {\n            this.subscriptions.push(engine);\n            return true;\n        }\n        return false;\n    };\n    AsyncEngine.prototype.unsubscribe = function (engine) {\n        this.subscriptions = this.subscriptions.filter(function (sub) { return sub != engine; });\n    };\n    AsyncEngine.prototype.task = function (fn, arg, target) {\n        return { fn: fn, arg: arg, target: target, engine: this };\n    };\n    AsyncEngine.prototype.schedule = function () {\n        var _this = this;\n        if (this.scheduled) {\n            return;\n        }\n        this.scheduled = true;\n        setTimeout(function () {\n            //            console.log(`[${this.name}] tick start`, this.tasks.length)\n            var t0 = performance.now();\n            _this.scheduled = false;\n            _this.processing = true;\n            //            console.log('tick')\n            var tasks = _this.tasks;\n            _this.tasks = [];\n            _this.deferred = _this.deferred.concat(_this.process(tasks));\n            // отправляем чужие задачи дальше по конвейеру\n            if (_this.tasks.length == 0) {\n                _this.deferred\n                    .filter(utils_1.subscriptionTaskFilter(_this.subscriptions))\n                    .filter(utils_1.unknownTaskFilter(_this.subscriptions));\n            }\n            else if (!_this.scheduled) {\n                console.error('Non scheduled tasks detected', _this.tasks);\n            }\n            _this.processing = false;\n            var t1 = performance.now();\n            console.log(\"[\" + _this.name + \"] patch end\", tasks.length, Math.round(t1 - t0), avgTimeInterval(t0, t1, tasks.length) /*, deleted ? '-'+deleted : ''*/);\n        });\n    };\n    AsyncEngine.prototype.process = function (tasks) {\n        return tasks.filter(utils_1.ownTaskFilter(this));\n    };\n    Object.defineProperty(AsyncEngine.prototype, \"isProcessing\", {\n        get: function () {\n            return this.processing;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return AsyncEngine;\n}());\nexports.AsyncEngine = AsyncEngine;\n//# sourceMappingURL=async.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BufferedEngine = void 0;\nvar utils_1 = require(\"./utils\");\nvar BufferedEngine = /** @class */ (function () {\n    function BufferedEngine() {\n        this.tasks = [];\n        this.subscriptions = [];\n        this.processing = false;\n    }\n    BufferedEngine.prototype.publish = function (task) {\n        if (task.done) {\n            return;\n        }\n        this.tasks.push(task);\n    };\n    BufferedEngine.prototype.subscribe = function (engine) {\n        if (this.subscriptions.indexOf(engine) == -1) {\n            this.subscriptions.push(engine);\n            return true;\n        }\n        return false;\n    };\n    BufferedEngine.prototype.unsubscribe = function (engine) {\n        this.subscriptions = this.subscriptions.filter(function (sub) { return sub != engine; });\n    };\n    BufferedEngine.prototype.task = function (fn, arg, target) {\n        return { fn: fn, arg: arg, target: target, engine: this };\n    };\n    BufferedEngine.prototype.flush = function () {\n        this.processing = true;\n        var tasks = this.tasks;\n        this.tasks = [];\n        tasks\n            .filter(utils_1.ownTaskFilter(this))\n            .filter(utils_1.subscriptionTaskFilter(this.subscriptions))\n            .filter(utils_1.unknownTaskFilter(this.subscriptions));\n        if (this.tasks.length > 0) {\n            this.flush();\n        }\n        this.processing = false;\n    };\n    Object.defineProperty(BufferedEngine.prototype, \"isProcessing\", {\n        get: function () {\n            return this.processing;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return BufferedEngine;\n}());\nexports.BufferedEngine = BufferedEngine;\n//# sourceMappingURL=buffered.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./async\"), exports);\n__exportStar(require(\"./buffered\"), exports);\n__exportStar(require(\"./pipe\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pipe = void 0;\nvar SimplePipe = /** @class */ (function () {\n    function SimplePipe(schedulers) {\n        this.head = schedulers[0];\n        this.subscriptions = [];\n        for (var i = 1; i < schedulers.length; i++) {\n            if (schedulers[i - 1].subscribe(schedulers[i])) {\n                this.subscriptions.push([schedulers[i - 1], schedulers[i]]);\n            }\n        }\n    }\n    SimplePipe.prototype.push = function (task) {\n        this.head.publish(task);\n        return this;\n    };\n    SimplePipe.prototype.asap = function (task) {\n        if (task.engine && task.engine.isProcessing) {\n            task.engine.publish(task);\n        }\n        else {\n            this.head.publish(task);\n        }\n        return this;\n    };\n    SimplePipe.prototype.destroy = function () {\n        this.subscriptions.forEach(function (sub) {\n            sub[0].unsubscribe(sub[1]);\n        });\n    };\n    return SimplePipe;\n}());\nvar pipe = function () {\n    var schedulers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        schedulers[_i] = arguments[_i];\n    }\n    return new SimplePipe(schedulers);\n};\nexports.pipe = pipe;\n//# sourceMappingURL=pipe.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unknownTaskFilter = exports.subscriptionTaskFilter = exports.ownTaskFilter = exports.ownTask = void 0;\nvar ownTask = function (fn, arg, target) {\n    return { fn: fn, arg: arg, target: target };\n};\nexports.ownTask = ownTask;\nvar ownTaskFilter = function (owner) { return function (task) {\n    var _a;\n    if (!task.engine || task.engine == owner) {\n        //        console.log('task', task.arg, task.target)\n        // исполняем задачу\n        (_a = task.fn) === null || _a === void 0 ? void 0 : _a.call(task.target, task.arg);\n        task.done = true;\n    }\n    else {\n        return true;\n    }\n}; };\nexports.ownTaskFilter = ownTaskFilter;\nvar subscriptionTaskFilter = function (subscriptions) { return function (task) {\n    var engine = subscriptions.find(function (sub) { return sub == task.engine; });\n    if (engine) {\n        engine.publish(task);\n    }\n    else {\n        return true;\n    }\n}; };\nexports.subscriptionTaskFilter = subscriptionTaskFilter;\nvar unknownTaskFilter = function (subscriptions) { return function (task) {\n    subscriptions.forEach(function (sub) {\n        sub.publish(task);\n    });\n}; };\nexports.unknownTaskFilter = unknownTaskFilter;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconcile = exports.ItemOp = void 0;\nvar ItemOp;\n(function (ItemOp) {\n    ItemOp[\"ADD\"] = \"add\";\n    ItemOp[\"DELETE\"] = \"delete\";\n    ItemOp[\"UPDATE\"] = \"update\";\n})(ItemOp = exports.ItemOp || (exports.ItemOp = {}));\nvar toSequence = function (items) {\n    var head = null;\n    var tail = null;\n    var map = {};\n    items.forEach(function (itm, i) {\n        var link = {\n            item: itm,\n            key: itm.key,\n            index: i,\n            before: tail,\n            after: null\n        };\n        map[itm.key] = link;\n        if (head == null) {\n            head = link;\n        }\n        if (tail) {\n            tail.after = link;\n        }\n        tail = link;\n    });\n    return [head, map];\n};\n// const toMap = (items: KVItem[]) : {[key: string]: KVItem} => {\n//     const map: {[key: string]: KVItem} = {}\n//     items.forEach(itm => {\n//         map[itm.key] = itm\n//     })\n// }\n// const mergeLinks = (prevLink: Link, nextLink: Link) : Link => {\n// }\nvar reconcile = function (prevItems, nextItems) {\n    // TODO должна быть проверка на уникальность ключей\n    //    console.log('----------------------------------------------')\n    if (prevItems.length == 0) {\n        return nextItems.map(function (itm) {\n            itm.op = ItemOp.ADD;\n            return itm;\n        });\n    }\n    if (nextItems.length == 0) {\n        return prevItems.map(function (itm) {\n            itm.op = ItemOp.DELETE;\n            return itm;\n        });\n    }\n    //  преобразуем массивы в последовательности\n    var _a = toSequence(prevItems), prevSeq = _a[0], prevMap = _a[1];\n    var _b = toSequence(nextItems), nextSeq = _b[0], nextMap = _b[1];\n    var seqMap = {};\n    // сливаем последовательности\n    for (var k in prevMap) {\n        seqMap[k] = prevMap[k];\n    }\n    for (var k in nextMap) {\n        if (!seqMap[k]) {\n            seqMap[k] = { key: k, index: -1 }; //nextMap[k].index}\n        }\n    }\n    for (var k in nextMap) {\n        var next = nextMap[k];\n        var link = seqMap[k];\n        link.item2 = next.item;\n        link.before2 = next.before && seqMap[next.before.key];\n        link.after2 = next.after && seqMap[next.after.key];\n    }\n    var sequence = [];\n    var head = seqMap[nextItems[0].key];\n    //    console.log(seqMap)\n    var tail = head;\n    // двигаемся вдоль новой головы до первого общего узла\n    while (tail && tail.item == null) {\n        tail.merged = true;\n        sequence.push(tail);\n        tail = tail.after2;\n    }\n    var saved = tail;\n    if (tail == null) {\n        tail = seqMap[prevItems[0].key];\n    }\n    // ищем старую голову\n    while (tail.before) {\n        tail = tail.before;\n    }\n    // двигаемся вдоль старой головы до первого общего узла\n    while (tail && tail.item2 == null) {\n        tail.merged = true;\n        sequence.push(tail);\n        tail = tail.after;\n    }\n    // возвращаемся к прерванному обходу\n    tail = saved;\n    while (tail) {\n        tail.merged = true;\n        sequence.push(tail);\n        if (tail.after2) {\n            if (tail.after2.index > tail.index) {\n                // собираем старые узлы после\n                var node = tail.after;\n                while (node && node.item2 == null && !node.merged) {\n                    node.merged = true;\n                    sequence.push(node);\n                    node = node.after;\n                }\n            }\n            else {\n                // собираем старые узлы до\n                var node = tail.before;\n                while (node && node.item2 == null && !node.merged) {\n                    node.merged = true;\n                    sequence.push(node);\n                    node = node.before;\n                }\n            }\n        }\n        tail = tail.after2;\n    }\n    // двигаемся назад по новому хвосту\n    tail = sequence[sequence.length - 1];\n    while (tail && tail.item == null) {\n        tail = tail.before2;\n    }\n    while (tail) {\n        if (!tail.merged) {\n            sequence.push(tail);\n        }\n        tail = tail.after;\n    }\n    //     console.log(sequence)\n    return sequence.map(function (link) {\n        var item = {\n            key: link.key,\n            value: null //link.item || link.item2\n        };\n        if (link.item && link.item2) {\n            item.op = ItemOp.UPDATE;\n            item.value = link.item.value;\n        }\n        else if (link.item) {\n            item.op = ItemOp.DELETE;\n            item.value = link.item.value;\n        }\n        else {\n            item.op = ItemOp.ADD;\n            item.value = link.item2.value;\n        }\n        return item;\n    });\n};\nexports.reconcile = reconcile;\n//# sourceMappingURL=reconcile.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./node\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DomNode = void 0;\nvar value_1 = require(\"../value\");\nvar pubsub_1 = require(\"../value/pubsub\");\n//export type DomEvents = GlobalEventHandlersEventMap\n// const DOM_EVENTS: Keyed<boolean> = {\n//     click: true,\n//     change: true,\n//     input: true,\n//     focus: true,\n//     blur: true\n// }\nvar DomNode = /** @class */ (function (_super) {\n    __extends(DomNode, _super);\n    function DomNode(renderer) {\n        var _this = _super.call(this, renderer.events) || this;\n        //        this._subscriptions = []\n        _this._effects = [];\n        return _this;\n    }\n    Object.defineProperty(DomNode.prototype, \"$eventHandlers\", {\n        // get $ref () {\n        //     return this._ref\n        // }\n        get: function () {\n            var _this = this;\n            var result = {};\n            this._handlers.forEach(function (h) {\n                result[h.name] = function (e) {\n                    _this.$emit(h.name, e);\n                };\n            });\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DomNode.prototype, \"$isSubscribed\", {\n        get: function () {\n            return this._subscriptions.length > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(DomNode.prototype, \"$value\", {\n        get: function () {\n            return this._el;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // set $value\n    // get $uid() : string {\n    //     return null\n    // }\n    // get $isTerminal() : boolean {\n    //     return true\n    // }\n    // $subscribe(subscriber: Subscriber<T>|PublishFunc<T>): Subscription {\n    //     // проверяем, что такая подписка уже есть\n    //     for (let sub of this._subscriptions) {\n    //         if (sub.subscriber == subscriber || sub.subscriber.$publish == subscriber) {\n    //             return sub\n    //         }\n    //     }    \n    //     if (typeof subscriber === 'function') {\n    //         subscriber = {\n    //             $publish: subscriber\n    //         }\n    //     }\n    //     const sub: Subscription = {\n    //         subscriber,\n    //         observable: this\n    //     }\n    //     this._subscriptions.push(sub)\n    //     return sub\n    // }\n    // $unsubscribe(subscription: Subscription|Subscriber<T>|PublishFunc<T>): void {\n    //     this._subscriptions = this._subscriptions.filter(sub => sub != subscription && sub.subscriber != subscription && sub.subscriber.$publish != subscription)\n    // }\n    DomNode.prototype.$publish = function (next, prev, keys) {\n        this._el = next;\n        this._subscriptions.forEach(function (sub) { return sub.subscriber.$publish(next); });\n    };\n    DomNode.prototype.$touch = function (subscriber) {\n        //        console.log('dom value', this._el)\n        subscriber.$publish(this._el, undefined, value_1.EMPTY);\n        // if (this._el) {\n        //     console.log('dom value already initialized')\n        // }\n        //        throw new Error(\"Method not implemented.\");\n    };\n    DomNode.prototype.$untouch = function () {\n    };\n    return DomNode;\n}(pubsub_1.PubSub));\nexports.DomNode = DomNode;\n//# sourceMappingURL=node.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildClassName = void 0;\n//export type VNodeFactory = <P, O>(key: string, vnodeProps: P, htmlProps: O&Dom, children?: any[]) => VNode\nvar buildClassName = function (cn, co) {\n    var classes = {};\n    if (cn) {\n        cn.split(' ').forEach(function (n) {\n            classes[n] = true;\n        });\n    }\n    if (!co) {\n    }\n    else if (Array.isArray(co)) {\n        for (var _i = 0, co_1 = co; _i < co_1.length; _i++) {\n            var cls = co_1[_i];\n            classes[cls] = true;\n        }\n    }\n    else if (typeof co === 'string') {\n        classes[co] = true;\n    }\n    else {\n        for (var i in co) {\n            if (co[i] !== undefined) {\n                classes[i] = co[i];\n            }\n        }\n        //Object.assign(classes, co)\n    }\n    var cn_a = [];\n    for (var i in classes) {\n        if (classes[i]) {\n            cn_a.push(i);\n        }\n    }\n    return cn_a.length ? cn_a.join(' ') : null;\n};\nexports.buildClassName = buildClassName;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultRules = void 0;\nvar mix_1 = require(\"./mix\");\nvar Option = function (x, y) {\n    return new mix_1.Mixin(x, y);\n};\n//const State = (x, y) => {return new State(x, y)}\nvar OptionCollection = function (x, y) {\n    if (y === false) {\n        return false;\n    }\n    else if (y === true) {\n        return true;\n    }\n    // if (x === undefined && y == undefined) {\n    //   return \n    // }\n    if (y && y.constructor != Object) {\n        x && console.warn('Ignore prev options', x);\n        return y;\n    }\n    if (x && x.constructor != Object) {\n        y && console.warn('Ignore new options', y);\n        return x;\n    }\n    //    console.log(x && x.constructor, y && y.constructor)\n    var kv = undefined;\n    if (x != null) {\n        kv = kv || {};\n        for (var i in x) {\n            kv[i] = new mix_1.Mixin(x[i]);\n        }\n    }\n    if (y != null) {\n        kv = kv || {};\n        //      console.log('y', y)\n        for (var i in y) {\n            kv[i] = kv[i] ? kv[i].mix(y[i]) : new mix_1.Mixin(y[i]);\n        }\n    }\n    //  console.log(kv)\n    return kv;\n};\nvar OptionArray = function (x, y) {\n    // TODO\n};\nvar StringArray = function (x, y) {\n    var arr = [];\n    if (x != null) {\n        arr = [].concat(x);\n    }\n    if (y != null) {\n        arr = arr.concat(y);\n    }\n    return arr;\n};\nvar Overlap = function (x, y) {\n    return y;\n};\nvar OptionCollectionOverlap = function (x, y) {\n    //    console.log('overlap', x, y)\n    if (y === false) {\n        return false;\n    }\n    else if (y === true) {\n        return x;\n    }\n    if (y && y.constructor != Object) {\n        x && console.warn('Ignore prev options', x);\n        return y;\n    }\n    if (x && x.constructor != Object) {\n        y && console.warn('Ignore new options', y);\n        return x;\n    }\n    //     console.log(x && x.constructor, y && y.constructor)\n    var kv = {};\n    if (x != null) {\n        for (var i in x) {\n            kv[i] = new mix_1.Mixin(x[i]);\n        }\n    }\n    if (y != null) {\n        //      console.log('y+', y)\n        for (var i in y) {\n            kv[i] = new mix_1.Mixin(y[i]);\n        }\n    }\n    //    console.log(JSON.stringify(kv))\n    return kv;\n};\nexports.DefaultRules = {\n    Option: Option,\n    OptionCollection: OptionCollection,\n    OptionArray: OptionArray,\n    StringArray: StringArray,\n    Overlap: Overlap,\n    OptionCollectionOverlap: OptionCollectionOverlap\n};\n//# sourceMappingURL=rules.js.map","\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventNode = exports.spyHandlers = void 0;\nvar _SpyHandlers = null;\nvar spyHandlers = function (fn) {\n    var prevHandlers = _SpyHandlers;\n    _SpyHandlers = [];\n    fn();\n    var result = _SpyHandlers;\n    _SpyHandlers = prevHandlers;\n    return result;\n};\nexports.spyHandlers = spyHandlers;\nvar EventNode = /** @class */ (function () {\n    function EventNode(global) {\n        this._global = global;\n        this._events = {};\n        this._handlers = [];\n    }\n    EventNode.prototype.$on = function (name, callback, target) {\n        var h = { name: name, callback: callback, target: target, bus: this };\n        this._handlers.push(h);\n        if (_SpyHandlers) {\n            _SpyHandlers.push(h);\n        }\n        return h;\n    };\n    EventNode.prototype.$off = function (ctl) {\n        this._handlers = this._handlers.filter(function (l) { return l != ctl && l.callback != ctl && l.target != ctl; });\n    };\n    EventNode.prototype.$emit = function (name) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        //        console.log('emit', name, args, this._handlers)\n        // TODO возможно, сообщения стоит здесь только помещать в очередь\n        this._handlers.forEach(function (h) {\n            if (h.name == name) {\n                //                console.log('call handler')\n                h.callback.apply(h.target, args);\n            }\n        });\n    };\n    EventNode.prototype.$event = function (name) {\n        var _this = this;\n        this._events[name] = true;\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return _this.$emit.apply(_this, __spreadArray([name], args));\n        };\n    };\n    EventNode.prototype.$hasEvent = function (name) {\n        return !!this._events[name] || (this._global != null && this._global[name]);\n    };\n    return EventNode;\n}());\nexports.EventNode = EventNode;\n//# sourceMappingURL=bus.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCallable = exports.callable = void 0;\nvar node_1 = require(\"./node\");\nvar observable_1 = require(\"./observable\");\nvar _Node = /** @class */ (function (_super) {\n    __extends(_Node, _super);\n    function _Node() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return _Node;\n}(node_1.Node));\nvar CallableNode = /** @class */ (function (_super) {\n    __extends(CallableNode, _super);\n    function CallableNode(initValue) {\n        var _this = _super.call(this) || this;\n        _this._memoValue = initValue;\n        _this._value = new _Node();\n        return _this;\n        //this._events = new EventNode()\n    }\n    CallableNode.prototype.$subscribe = function (subscriber) {\n        return this._value.$subscribe(subscriber);\n    };\n    CallableNode.prototype.$unsubscribe = function (subscription) {\n        this._value.$unsubscribe(subscription);\n    };\n    CallableNode.prototype.$touch = function (subscriber) {\n        //throw new Error(\"Method not implemented.\")\n    };\n    CallableNode.prototype.$untouch = function () {\n        //throw new Error(\"Method not implemented.\")\n    };\n    CallableNode.prototype.$publish = function (next, prev, keys) {\n        this._value.$publish(next, prev, keys);\n    };\n    CallableNode.prototype.$call = function (thisArg, args) {\n        var _this = this;\n        if (this._memoValue == null) {\n            console.warn('Possible uninitialized callable', args);\n        }\n        var result = this._memoValue != null ? this._memoValue.apply(thisArg, args) : args[0];\n        if (observable_1.isValueSet(result)) {\n            result = result.$value;\n        }\n        if (result && result.then) {\n            this.$emit('wait');\n            result = result.then(function (response) {\n                _this.$emit('done', response);\n                //                this.$publish(response)\n                return response;\n            }, function (fail) {\n                _this.$emit('fail', fail);\n                return fail;\n            });\n        }\n        else {\n            this.$emit('done', result);\n            //            this.$publish(result)\n        }\n        return result;\n    };\n    CallableNode.prototype.$emit = function (name) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this._value.$emit.apply(this._value, __spreadArray([name], args));\n    };\n    CallableNode.prototype.$on = function (name, callback, target) {\n        return this._value.$on(name, callback, target);\n    };\n    CallableNode.prototype.$off = function (callbackOrTargetOrListener) {\n        this._value.$off(callbackOrTargetOrListener);\n    };\n    CallableNode.prototype.$event = function (name) {\n        return null;\n        //throw new Error(\"Method not implemented.\")\n    };\n    CallableNode.prototype.$hasEvent = function (name) {\n        return false;\n        //throw new Error(\"Method not implemented.\")\n    };\n    Object.defineProperty(CallableNode.prototype, \"$value\", {\n        get: function () {\n            return this._memoValue;\n        },\n        set: function (value) {\n            this._memoValue = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CallableNode.prototype, \"$uid\", {\n        get: function () {\n            return '';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CallableNode.prototype, \"$isTerminal\", {\n        get: function () {\n            return true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // FIXME убрать после проверки наличия событий в Hub\n    CallableNode.prototype.$has = function () {\n        return false;\n    };\n    CallableNode.prototype.$at = function () {\n        return null;\n    };\n    return CallableNode;\n}(Function));\nvar callable = function (initValue) {\n    //const value = isValueSet(initValue) ? initValue.$value : initValue\n    return observable_1.proxify(initValue, new CallableNode(initValue));\n};\nexports.callable = callable;\nvar isCallable = function (v) {\n    return v && typeof v.$call === 'function';\n};\nexports.isCallable = isCallable;\n//# sourceMappingURL=callable.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computable = void 0;\nvar engine_1 = require(\"./engine\");\nvar node_1 = require(\"./node\");\nvar observable_1 = require(\"./observable\");\nvar utils_1 = require(\"./utils\");\nvar ComputableNode = /** @class */ (function (_super) {\n    __extends(ComputableNode, _super);\n    function ComputableNode(computor, initValue, entryUidFunc) {\n        var _this = _super.call(this, initValue, undefined, undefined, entryUidFunc) || this;\n        _this._computor = computor;\n        _this._initialized = false; // отменяем инициализацию\n        _this._sources = new Set();\n        return _this;\n        //this._publishers = []\n        //this._touched = false\n    }\n    ComputableNode.prototype.$compute = function () {\n        var _this = this;\n        if (this._computing) {\n            return this._memoValue;\n        }\n        this._computing = true;\n        var next = undefined;\n        // this._publishers.forEach(dep => {\n        //     if ((dep.observable as any)._destroyed) {\n        //         console.warn('Destroyed dependency detected', dep)\n        //         this._destroyed = true\n        //     }\n        // })\n        // if (this._destroyed) {\n        //     this._publishers.forEach(dep => {\n        //     })\n        //     return undefined\n        // }\n        // this._publishers = []\n        //         this._sources.forEach(dep => {\n        //             if ((dep as any)._destroyed) {\n        //                 // TODO поместить в очередь на удаление\n        //                 this._destroyed = true\n        //             }\n        //         })\n        //         if (this._destroyed) {\n        //             this._sources.forEach(dep => {\n        //                 dep.$unsubscribe(this)\n        //             })\n        //             this._sources.clear()\n        // //            this._destroyed = false\n        //             return\n        //         }\n        var getters = node_1.spyGetters(function () {\n            next = observable_1.autoTerminalAware(_this._computor);\n        });\n        this._computing = false;\n        // getters.forEach(dep => {\n        //     if ((dep as any)._destroyed) {\n        //         console.warn('Destroyed dependency detected', dep)\n        //         this._destroyed = true\n        //     }\n        // })\n        // if (!this._destroyed) {\n        getters.forEach(function (dep) {\n            // автоподписка\n            dep.$subscribe(_this);\n            _this._sources.add(dep);\n        });\n        // }\n        if (observable_1.isValueSet(next)) {\n            next = next.$value;\n        }\n        return next;\n    };\n    // $touch(subscriber: Subscriber<T>): void {\n    //     let value = undefined\n    //     if (!this._touched) {\n    //         value = this.$compute()\n    //         this._touched = true\n    //     }\n    //     subscriber.$publish(value, undefined, EMPTY)       \n    // }\n    ComputableNode.prototype.$publish = function (next, prev, keys) {\n        //        console.log('publish computable', next)\n        var _this = this;\n        if (this._destroyed) {\n            console.warn('Publishing to destroyed computable');\n            return;\n        }\n        var computed = undefined;\n        try {\n            computed = this.$compute();\n        }\n        catch (err) {\n            console.error('Compute error', err);\n        }\n        if (computed && typeof computed.$at === 'function') {\n            computed = computed.$value;\n        }\n        if (this.$isPrimitive && computed === this._memoValue) {\n            //            console.log('No change detected', computed, this._memoValue)\n            return;\n        }\n        var t = engine_1.openTransaction();\n        _super.prototype.$publish.call(this, computed, null, utils_1.EMPTY);\n        var count = 0;\n        engine_1.transactionUpdates(t).forEach(function (upd) {\n            // FIXME\n            count += upd.node.$subscriptions.length;\n        });\n        if (count == 0) {\n            //            debugger\n            this._sources.forEach(function (dep) {\n                dep.$unsubscribe(_this);\n            });\n            this._sources.clear();\n            this._initialized = false;\n            //            this._destroyed = true\n            //            console.log('unsubscribed computable detected [publish]')\n        }\n        engine_1.closeTransaction(t);\n        // this._updateEntries(computed)\n        // // у вычисляемых значений нет родителя/источника, поэтому обновляем поддерево только вниз\n        // this.$update(UpdateDirection.DESC, computed, null, EMPTY)    \n    };\n    ComputableNode.prototype.$unsubscribe = function (subscription) {\n        var _this = this;\n        _super.prototype.$unsubscribe.call(this, subscription);\n        // быстрая проверка на отписку\n        if (this._subscriptions.length == 0 && Object.keys(this._entries).length == 0) {\n            this._sources.forEach(function (dep) {\n                dep.$unsubscribe(_this);\n            });\n            this._sources.clear();\n            this._initialized = false;\n            //            this._destroyed = true\n            //            console.log('unsubscribed computable detected [unsubscribe]')\n        }\n    };\n    ComputableNode.prototype.$get = function () {\n        //        console.log('compute')\n        return this._initialized ? this._memoValue : this.$compute();\n    };\n    return ComputableNode;\n}(observable_1.ObservableNode));\n//const _computeQue: ComputableNode<any>[] = []\nvar computable = function (compute, initValue, entryUidFunc) {\n    var c = observable_1.proxify(null, new ComputableNode(compute, initValue, entryUidFunc));\n    // TODO переделать в compute engine?\n    // if (_computeQue.length == 0) {\n    //     setTimeout(() => {\n    //         while(_computeQue.length) {\n    //             _computeQue.shift().$publish(null)\n    //         }\n    //     })    \n    // }\n    // _computeQue.push(c)\n    return c;\n};\nexports.computable = computable;\n//# sourceMappingURL=computable.js.map","\"use strict\";\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.commitEngine = exports.currentTransaction = exports.transactionUpdates = exports.closeTransaction = exports.openTransaction = void 0;\nvar utils_1 = require(\"./utils\");\nvar _Session = null;\nvar openTransaction = function () {\n    var t = { joined: true };\n    if (!_Session) {\n        _Session = {\n            nodes: new Set(),\n            head: _this,\n            deleted: [],\n            updated: []\n        };\n        t.joined = false;\n    }\n    // else {\n    //     debugger\n    // }\n    return t;\n};\nexports.openTransaction = openTransaction;\nvar closeTransaction = function (t) {\n    if (!t.joined) {\n        if (_Session.updated.length > 0 || _Session.deleted.length > 0) {\n            _engine.addSession(_Session);\n        }\n        _Session = null;\n    }\n};\nexports.closeTransaction = closeTransaction;\nvar transactionUpdates = function (t) {\n    return _Session.updated;\n};\nexports.transactionUpdates = transactionUpdates;\nvar currentTransaction = function () {\n    return _Session;\n};\nexports.currentTransaction = currentTransaction;\nvar UpdateEngine = /** @class */ (function () {\n    //    _commitedSubscriptions: Set<Subscription>\n    function UpdateEngine() {\n        this._sessions = [];\n        this._commitedNodes = new Map();\n        //        this._commitedSubscriptions = new Set<Subscription>()\n    }\n    UpdateEngine.prototype.addSession = function (session) {\n        this._sessions.push(session);\n    };\n    UpdateEngine.prototype.commit = function () {\n        var _this = this;\n        if (!this._commiting) {\n            //            console.log('commit', this._sessions)\n            //            this._commitedNodes.size == 0 && console.log('Commit start')\n            this._commiting = true;\n            var sessions = this._sessions;\n            this._sessions = [];\n            sessions.forEach(function (session) {\n                //                console.log('session', session.updated)\n                // ?\n                session.deleted.forEach(function (del) {\n                    //                    if (del.$subscriptions.length == 0) {\n                    del.$destroy();\n                    // }\n                    // console.log('del has subscriptions', del)\n                });\n                //                const lastUpdateMap = new Map<Subscriber<any>, NodeUpdate>()\n                session.updated.forEach(function (upd) {\n                    if (_this._commitedNodes.has(upd.node)) {\n                        //console.warn('Cyclic update detected', upd.prev, upd.next)\n                        if (upd.next === _this._commitedNodes.get(upd.node)) {\n                            console.warn('Possible cyclic update', upd);\n                            return;\n                        }\n                        //                        return\n                    }\n                    upd.node.$subscriptions.forEach(function (sub) {\n                        //                        console.log('publish to subscriber', upd.next)\n                        sub.subscriber.$publish(upd.next, upd.prev, utils_1.EMPTY);\n                    });\n                    _this._commitedNodes.set(upd.node, upd.next);\n                });\n                // lastUpdateMap.forEach((upd, sub) => {\n                //     sub.$publish(upd.next, upd.prev, EMPTY)\n                // })\n                //                 session.updated.forEach(upd => {\n                //                     if (this._commitedNodes.has(upd.node)) {\n                //                         if (upd.next == 'filter: Albania') {\n                //                             debugger\n                //                         }\n                // //                        console.log('Already commited', upd, upd.node._memoValue)\n                //                         return\n                //                     }\n                //                     upd.node._subscriptions.forEach(sub => {\n                //                         sub.subscriber.$publish(upd.next, upd.prev, EMPTY)\n                //                     })\n                //                 })\n                //                this._commitedNodes.add(session.head as Node<any>)\n            });\n            this._commiting = false;\n            if (this._sessions.length > 0) {\n                this.commit();\n                //                console.log('commit')\n            }\n            else {\n                this._commitedNodes.clear();\n                //                console.log('Commit end')\n            }\n        }\n    };\n    return UpdateEngine;\n}());\nvar _engine = new UpdateEngine();\nvar commitEngine = function () {\n    return _engine;\n};\nexports.commitEngine = commitEngine;\n//# sourceMappingURL=engine.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./utils\"), exports);\n__exportStar(require(\"./node\"), exports);\n__exportStar(require(\"./observable\"), exports);\n__exportStar(require(\"./computable\"), exports);\n__exportStar(require(\"./iterator\"), exports);\n__exportStar(require(\"./iterable\"), exports);\n__exportStar(require(\"./callable\"), exports);\n__exportStar(require(\"./pubsub\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isIterable = exports.iterable = exports.IterableNode = void 0;\nvar node_1 = require(\"./node\");\nvar observable_1 = require(\"./observable\");\nvar IterableNode = /** @class */ (function (_super) {\n    __extends(IterableNode, _super);\n    function IterableNode(initValue, origin, key) {\n        var _this = _super.call(this) || this;\n        _this._origin = origin;\n        _this._name = key;\n        _this._memoValue = {}; // FIXME обманываем isTerminal\n        if (!origin) {\n            _this._origin = observable_1.observable(initValue);\n        }\n        // FIXME это не должно быть в конструкторе\n        _this._origin.$subscribe(_this);\n        return _this;\n    }\n    Object.defineProperty(IterableNode.prototype, \"$name\", {\n        get: function () {\n            return this._name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // $publish(next: any, prev?: any, keys?: {[key: string]: any}): void {\n    // }\n    IterableNode.prototype.$each = function (f) {\n        //        console.log('each')\n        var origin = this._origin; //|| this//(this as ValueSet<T>)\n        var v = origin.$value;\n        // console.log('each', v)\n        // console.log('each', (origin as any)._entries)\n        for (var i in v) {\n            f(origin.$at(i), i); // FIXME\n        }\n        //        console.log('each end')\n        // if (Array.isArray(v)) {\n        //     for (let i = 0; i < v.length; i++) {\n        //         f(origin.$at(i))\n        //     }\n        // }\n        // else {\n        //     for (let i in v) {\n        //         f(origin.$at(i as K))\n        //     }    \n        // }\n        // origin.$ownKeys().forEach(i => {\n        //     f(origin.$at(i as K))\n        // })\n    };\n    IterableNode.prototype.$unsubscribe = function (subscription) {\n        _super.prototype.$unsubscribe.call(this, subscription);\n        if (this._subscriptions.length == 0) {\n            this._origin.$unsubscribe(this);\n            this._origin = null;\n            this._initialized = false;\n            console.log('unsubscribed iterable detected [unsubscribe]');\n        }\n    };\n    return IterableNode;\n}(node_1.Node));\nexports.IterableNode = IterableNode;\nvar iterable = function (source, key) {\n    if (key === void 0) { key = '__it'; }\n    return (observable_1.isObservable(source) ? new IterableNode(null, source, key) : new IterableNode(source, null, key));\n};\nexports.iterable = iterable;\nvar isIterable = function (v) {\n    return v != null && typeof v.$each === 'function';\n};\nexports.isIterable = isIterable;\n//# sourceMappingURL=iterable.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservableValueIterator = void 0;\nvar ObservableValueIterator = /** @class */ (function () {\n    function ObservableValueIterator(source, key) {\n        this.source = source;\n        this.index = -1;\n        this.key = key;\n    }\n    ObservableValueIterator.prototype.next = function () {\n        if (this.source == null) {\n            return { done: true };\n        }\n        if (this.index == -1) {\n            var v = this.source.$value;\n            if (Array.isArray(v)) {\n                this.maxIndex = v.length;\n            }\n            else if (typeof v === 'object') {\n                this.keys = Object.keys(v);\n            }\n            else {\n                console.error('Value is not iterable', v);\n            }\n        }\n        this.index++;\n        var result = {\n            done: false\n        };\n        if (this.keys) {\n            if (this.index < this.keys.length) {\n                result.value = this.source.$at(this.keys[this.index]);\n            }\n            else {\n                result.done = true;\n            }\n        }\n        else {\n            if (this.index < this.maxIndex) {\n                result.value = this.source.$at(this.index);\n            }\n            else {\n                result.done = true;\n            }\n        }\n        return result;\n    };\n    Object.defineProperty(ObservableValueIterator.prototype, \"$name\", {\n        get: function () {\n            return this.key;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ObservableValueIterator;\n}());\nexports.ObservableValueIterator = ObservableValueIterator;\n// export const iterator = <T extends []|{}>(source: T, name: string = '__it') : ValueIterator<T> => {\n//     return new ObservableValueIterator(source as any, String(name))\n// }\n// export const next = <T>(scope: any, name: string = '__it') : Value<T> => {\n//     return scope[name]\n// }\n//# sourceMappingURL=iterator.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Node = exports.spyGetters = exports.IsCheck = exports.HasCheck = exports.UpdateDirection = void 0;\nvar utils_1 = require(\"./utils\");\nvar engine_1 = require(\"./engine\");\nvar pubsub_1 = require(\"./pubsub\");\nvar UpdateDirection;\n(function (UpdateDirection) {\n    UpdateDirection[UpdateDirection[\"ASC\"] = 0] = \"ASC\";\n    UpdateDirection[UpdateDirection[\"DESC\"] = 1] = \"DESC\";\n    UpdateDirection[UpdateDirection[\"BOTH\"] = 2] = \"BOTH\";\n})(UpdateDirection = exports.UpdateDirection || (exports.UpdateDirection = {}));\nvar HasCheck;\n(function (HasCheck) {\n    HasCheck[HasCheck[\"PROPERTY\"] = 0] = \"PROPERTY\";\n    HasCheck[HasCheck[\"METHOD\"] = 1] = \"METHOD\";\n})(HasCheck = exports.HasCheck || (exports.HasCheck = {}));\nvar IsCheck;\n(function (IsCheck) {\n    IsCheck[IsCheck[\"ARRAY\"] = 0] = \"ARRAY\";\n})(IsCheck = exports.IsCheck || (exports.IsCheck = {}));\n// Spies\nvar _SpyGetters = null;\n// let _SpySubscriptions : Subscription[] = null\n// export const spySubscriptions = (fn: Function) : Subscription[] => {\n//     const prevSub = _SpySubscriptions\n//     _SpySubscriptions = []\n//     fn()\n//     const result = _SpySubscriptions\n//     _SpySubscriptions = prevSub\n//     return result\n// }\nvar spyGetters = function (fn) {\n    var prevGetters = _SpyGetters;\n    _SpyGetters = [];\n    fn();\n    var result = _SpyGetters;\n    _SpyGetters = prevGetters;\n    return result;\n};\nexports.spyGetters = spyGetters;\n// const transactionAware = (fn: Function) => {\n//     if (_Session) {\n//         debugger\n//     }\n//     _Session = {\n//         nodes: new Set(),\n//         head: this,\n//         deleted: [],\n//         updated: []\n//     }\n//     fn()\n//     if (_Session.updated.length > 0 || _Session.deleted.length > 0) {\n//         _update_engine.addSession(_Session)\n//     }\n//     _Session = null\n// }\nvar Node = /** @class */ (function (_super) {\n    __extends(Node, _super);\n    function Node(initValue, source, key, entryUidFunc) {\n        var _this = _super.call(this) || this;\n        _this._memoValue = initValue;\n        _this._source = source;\n        _this._key = key;\n        _this._subscriptions = [];\n        _this._entries = {};\n        _this._uidFunc = entryUidFunc || utils_1.defaultUidFunc;\n        //        this._session = undefined\n        _this._uid = undefined;\n        _this._initialized = source == null;\n        _this._destroyed = false;\n        return _this;\n    }\n    Object.defineProperty(Node.prototype, \"$key\", {\n        get: function () {\n            return this._key;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"$source\", {\n        get: function () {\n            return this._source;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.toString = function () {\n        return String(this.$value);\n    };\n    Node.prototype.toJSON = function () {\n        console.log('to json');\n        return this.$value;\n    };\n    Node.prototype.valueOf = function () {\n        return this.$value;\n    };\n    Object.defineProperty(Node.prototype, Symbol.toStringTag, {\n        get: function () {\n            var v = Object.prototype.toString.call(this.$value);\n            return v.substring(8, v.length - 1);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype[Symbol.toPrimitive] = function () {\n        var v = this.$value;\n        if (typeof v === 'object') {\n            return String(v);\n        }\n        return v; // this.$value//[Symbol.toPrimitive]\n    };\n    Object.defineProperty(Node.prototype, Symbol.isConcatSpreadable, {\n        get: function () {\n            return Array.isArray(this.$value); //this._memoValue && this._memoValue[Symbol.isConcatSpreadable]\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"$uid\", {\n        get: function () {\n            if (_SpyGetters) {\n                _SpyGetters.push(this);\n            }\n            return this._uid;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"$isTerminal\", {\n        get: function () {\n            var v = this.$value;\n            return (v == null || (typeof v == 'string') || (typeof v == 'number') || (typeof v == 'symbol') || (typeof v == 'boolean') || (typeof v == 'function')); // || Array.isArray(v))\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"$isPrimitive\", {\n        get: function () {\n            var v = this.$value;\n            return (v == null || (typeof v == 'string') || (typeof v == 'number') || (typeof v == 'symbol') || (typeof v == 'boolean') || (typeof v == 'function'));\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"$value\", {\n        get: function () {\n            if (_SpyGetters) {\n                _SpyGetters.push(this);\n            }\n            if (this._destroyed) {\n                console.error('Value in destroyed state', this);\n                return undefined;\n                //            debugger\n            }\n            if (!this._initialized) {\n                this._memoValue = this.$get();\n                // if (this._memoValue && typeof this._memoValue.$at === 'function') {\n                //     this._memoValue = this._memoValue.$value\n                // }\n                this._initialized = true;\n            }\n            if (this._memoValue && typeof this._memoValue.$at === 'function') {\n                debugger;\n            }\n            return this._memoValue;\n        },\n        set: function (newValue) {\n            if (this._destroyed) {\n                console.error('Value drop destroyed state', this);\n                this._destroyed = false;\n            }\n            // если новое значение является наблюдаемым, то берем только его значение\n            // сейчас эта проверка дублирует аналогичную в publish\n            if (newValue && typeof newValue.$at === 'function') {\n                newValue = newValue.$value;\n            }\n            if (this.$isPrimitive && newValue === this._memoValue) {\n                //            console.log('No change detected', newValue, this._memoValue)\n                return;\n            }\n            //        transactionAware(() => {\n            this.$publish(newValue, this._memoValue, utils_1.EMPTY);\n            //        })\n            // // обновляем дерево значений\n            // if (_Session) {\n            //     debugger\n            // }\n            // _Session = {\n            //     nodes: new Set(),\n            //     head: this,\n            //     deleted: [],\n            //     updated: []\n            // }\n            // // const prevSession = _Session\n            // // _Session = null\n            //  // _Session = prevSession\n            // _update_engine.addSession(_Session)\n            // _Session = null\n            engine_1.commitEngine().commit();\n            // if (newValue != null) {\n            //     if ((newValue as ValueNode<any>).$at) {\n            //         newValue = (newValue as Value<any>).$value\n            //     }\n            //     this._updateEntries(newValue)\n            // }\n            // this.$update(UpdateDirection.BOTH, newValue, null, EMPTY)\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Node.prototype.$hasFunction = function (key) {\n        var v = this.$value;\n        return v != null && typeof v[key] == 'function';\n    };\n    // -----------------\n    // Pub/Sub\n    // -----------------\n    Node.prototype.$publish = function (next, prev, keys) {\n        //       console.log('publish')\n        if (!this._initialized) {\n            console.warn('Value is not initialized', this);\n            this._initialized = true; // FIXME насколько это корректно?\n        }\n        // if (this._destroyed) {\n        //     console.warn('Value destroyed', this)\n        //     return\n        // }\n        var t = engine_1.openTransaction();\n        //         let session = null\n        //         if (!_Session) {\n        //             _Session = {\n        //                 nodes: new Set(),\n        //                 head: this,\n        //                 deleted: [],\n        //                 updated: []\n        //             }\n        //             session = _Session\n        // //            console.log('Session start', this)\n        //         }\n        //         else {\n        //             if (this._source == null) {\n        // //                console.log('Root node detected', next, this)\n        //             }    \n        //         }\n        //         if (_Session.nodes.has(this)) {\n        // //            console.log('Already in session', this)\n        //             return\n        //         }\n        if (next != null) {\n            if (typeof next.$update === 'function') {\n                next = next.$value;\n            }\n            //            this._updateEntries(next)\n        }\n        this.$update(UpdateDirection.BOTH, next, null, utils_1.EMPTY);\n        engine_1.closeTransaction(t);\n        //         if (session) {\n        //             _Session = null\n        //             _update_engine.addSession(session)\n        //             // session.deferred.forEach(node => {\n        //             //     node._subscriptions.forEach(sub => sub.subscriber.$publish(node._memoValue, prev, EMPTY))\n        //             // })\n        // //            console.log(_Session.deleted)\n        // //            session.deleted.forEach(node => node.$destroy())\n        // //            console.log('Session end', this)\n        //         }\n    };\n    Node.prototype.$touch = function (subscriber) {\n        //this._started = true\n        subscriber.$publish(this.$value, undefined, utils_1.EMPTY);\n    };\n    Node.prototype.$untouch = function () {\n        // TODO проверки при отсоединении\n    };\n    // ----------------\n    // Node\n    // ----------------\n    // abstract $at <I=T[K]>(key: K, factory?: Function): ValueSet<I>\n    Node.prototype.$update = function (direction, value, key, keyInfo) {\n        var _a;\n        if (this._destroyed) {\n            console.error('Value destroyed and should not be updated', this);\n            return;\n        }\n        // if (this._key == 'filter') {\n        //     console.log('update filter', value)\n        // }\n        //        console.log('update', this._key, this._memoValue, this._entries)\n        // else {\n        //     if (_Session.nodes.has(this)) {\n        //         return\n        //     }\n        // }\n        //        _Session.nodes.add(this)\n        //        this._session = _Session\n        var prev = this._memoValue;\n        if (direction == UpdateDirection.ASC) {\n            this._memoValue[key] = value;\n        }\n        else {\n            this._memoValue = value;\n        }\n        // уведомление дочерних элементов\n        if (direction == UpdateDirection.DESC || direction == UpdateDirection.BOTH) {\n            this._updateEntries(value);\n            for (var i in this._entries) {\n                this._entries[i].$update(UpdateDirection.DESC, this._memoValue == null ? undefined : this._memoValue[i]);\n            }\n        }\n        // уведомление родительского элемента\n        if (direction == UpdateDirection.ASC || direction == UpdateDirection.BOTH) {\n            if (this._source) {\n                this._source.$update(UpdateDirection.ASC, this._memoValue, this._key, (_a = {}, _a[this._key] = keyInfo, _a));\n            }\n        }\n        var t = engine_1.currentTransaction();\n        if (t) {\n            t.updated.push({\n                node: this,\n                next: this._memoValue,\n                prev: prev\n            });\n        }\n        //        console.log('notify', this._key, this._memoValue)\n    };\n    // ----------------\n    // internal\n    // ----------------\n    Node.prototype._updateEntries = function (newValue) {\n        var _this = this;\n        var nextEntries = {};\n        var reuseMap = {};\n        if (Array.isArray(newValue)) {\n            for (var k in this._entries) {\n                var uid = this._entries[k].$uid;\n                if (uid == undefined) {\n                    uid = this._uidFunc(this._entries[k].$value);\n                    if (uid === undefined) {\n                        uid = String(k);\n                    }\n                }\n                reuseMap[uid] = this._entries[k];\n            }\n            //            Object.assign(reuseMap, this._entries)\n            //            const uidFunc = this._uidFunc || defaultUidFunc\n            // prevMap составляем только на основе индексированных значений, чтобы значения свойтв (length)\n            // не перекрывали ключи\n            // newValue.forEach((v, k) => {\n            //     if (k in this._entries) {\n            //         let uid = this._entries[k].$uid// (this._entries[k] as Axle<any>)._uid// uidFunc(this._entries[k].$value) //(this._entries[k] as Value<any>).$uid\n            //         if (uid === undefined) {\n            //             uid = this._uidFunc(this._entries[k].$value)\n            //             if (uid === undefined) {\n            //                 uid = String(k)\n            //             }\n            //         }\n            //         reuseMap[uid] = this._entries[k]\n            //     }\n            // })\n            // for (let k in this._entries) {\n            //     let uid = this._entries[k].$uid// (this._entries[k] as Axle<any>)._uid// uidFunc(this._entries[k].$value) //(this._entries[k] as Value<any>).$uid\n            //     if (uid === undefined) {\n            //         uid = this._uidFunc(this._entries[k].$value)\n            //         if (uid === undefined) {\n            //             uid = k\n            //         }\n            //     }\n            //     prevMap[uid] = this._entries[k]\n            // }\n            //            console.log(this._key, Object.keys(reuseMap))\n            //            const nextMap: {[key: string]: any} = {}\n            newValue.forEach(function (v, i) {\n                var uid = _this._uidFunc(v);\n                if (uid === undefined) {\n                    uid = String(i);\n                }\n                var entry = reuseMap[uid];\n                if (entry) {\n                    //                    console.log('reuse entry', [entry._key, entry._uid], [i, uid])\n                    nextEntries[i] = entry;\n                    entry._key = String(i);\n                    entry._uid = uid;\n                    entry._memoValue = v;\n                    delete reuseMap[uid];\n                }\n                else {\n                }\n                //                nextMap[uid] = v\n            });\n            //            console.log('rest reuse map', this._key, reuseMap)\n            //            console.log(this._key, nextEntries)\n        }\n        else if (newValue && newValue.constructor === Object) {\n            Object.assign(reuseMap, this._entries);\n            for (var k in newValue) {\n                // const v = newValue[k]\n                // const uid = k//uidFunc(v)\n                var entry = this._entries[k]; // prevMap[uid]\n                if (entry) {\n                    nextEntries[k] = entry;\n                    entry._key = k;\n                    entry._uid = k;\n                    delete reuseMap[k];\n                    // ?\n                    if (entry._destroyed) {\n                        console.log('Entry restored', entry);\n                        entry._subscriptions.length > 0 && console.error('Restored entry has subscriptions', entry);\n                        entry._destroyed = false;\n                    }\n                }\n                else {\n                }\n            }\n        }\n        // else {\n        //     Object.assign(prevMap, this._entries)\n        // }\n        this._entries = nextEntries;\n        for (var i in reuseMap) {\n            var removed = reuseMap[i];\n            // замененные элементы\n            if (i in nextEntries) {\n                console.log('replaced', reuseMap[i]);\n            }\n            else {\n                if (i != removed._key) {\n                    console.warn('removed and changed key', i, removed._key, removed.$uid); //, removed)\n                    //console.log(prevMap)\n                }\n                if (removed._subscriptions.length > 0) {\n                    if (this._entries[String(removed._key)]) {\n                        debugger;\n                    }\n                    else {\n                        this._entries[String(removed._key)] = removed;\n                    }\n                    //                    removed._destroyed = true\n                    continue;\n                }\n                console.log('removed', removed._key, removed._memoValue);\n            }\n            var t = engine_1.currentTransaction();\n            if (t) {\n                t.deleted.push(reuseMap[i]);\n            }\n            //            if (!(i in nextEntries)) {\n            // этот элемент идет на удаление\n            //                console.log('delete', i)\n            //                if (!_Sess)\n            //                prevMap[i]._destroy()\n            //            }\n        }\n    };\n    // _createEntry (value: T, key: ValueKey) : Node<T> {\n    //     return null// new Node(value, this, key)\n    // }\n    Node.prototype.$get = function () {\n        if (this._initialized) {\n            return this._memoValue;\n        }\n        var v = this._source.$get();\n        return v == null ? v : v[this._key];\n        //        return this._initialized ? this._memoValue : (this._source.$get() as any)[this._key]\n    };\n    Node.prototype.$destroy = function () {\n        console.log('destroy', this._key, this._memoValue, this._subscriptions.length);\n        this._destroyed = true;\n        for (var i in this._entries) {\n            //            console.log('destroy', i)\n            this._entries[i].$destroy();\n        }\n        this._memoValue = undefined;\n        // ?\n        // this._subscriptions.forEach(sub => {\n        //     sub.subscriber.$publish(undefined, this._memoValue, EMPTY)\n        // })\n        // this._subscriptions = []\n        // this._entries = null\n        // this._source = null\n        //        console.log('deleted', this._key)\n        // FIXME здесь нужно каскадное обновление\n        //        this.$update(UpdateDirection.DESC, undefined, this._memoValue, EMPTY)\n        //        this._subscriptions.forEach(sub => sub.subscriber.$publish(undefined, this._memoValue, EMPTY))\n    };\n    return Node;\n}(pubsub_1.PubSub));\nexports.Node = Node;\n//# sourceMappingURL=node.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.proxify = exports.__isValue = exports.__isProxy = exports.isValueIterator = exports.isValueSet = exports.isObservable = exports.reactive = exports.observable = exports.ObservableNode = exports.isAutoTerminal = exports.noAutoTerminal = exports.autoTerminalAware = void 0;\nvar node_1 = require(\"./node\");\nvar _AutoTerminal = false;\nvar autoTerminalAware = function (fn) {\n    var prevAutoTermial = _AutoTerminal;\n    _AutoTerminal = true;\n    try {\n        var result = fn();\n        return result;\n    }\n    finally {\n        _AutoTerminal = prevAutoTermial;\n    }\n};\nexports.autoTerminalAware = autoTerminalAware;\nvar noAutoTerminal = function (fn) {\n    var prevAutoTermial = _AutoTerminal;\n    _AutoTerminal = false;\n    try {\n        var result = fn();\n        return result;\n    }\n    finally {\n        _AutoTerminal = prevAutoTermial;\n    }\n};\nexports.noAutoTerminal = noAutoTerminal;\nvar isAutoTerminal = function () { return _AutoTerminal; };\nexports.isAutoTerminal = isAutoTerminal;\nvar ObservableNode = /** @class */ (function (_super) {\n    __extends(ObservableNode, _super);\n    function ObservableNode() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ObservableNode.prototype.$at = function (k, creator) {\n        var entry = this._entries[String(k)];\n        if (!entry) {\n            var value = this._memoValue ? this._memoValue[k] : null;\n            // if (value && typeof value.$at === 'function') {\n            //     value = value.$value\n            // }\n            entry = creator ? creator(this, k) : this._createEntry(value, k);\n            // FIXME\n            entry._uid = this._uidFunc(value);\n            //            entry = proxify(entry.$value, entry)\n            this._entries[String(k)] = entry;\n        }\n        return entry; // FIXME\n    };\n    ObservableNode.prototype.$has = function (key, check) {\n        var v = this.$value;\n        if (v != null && v[key] != null) {\n            if (check == node_1.HasCheck.METHOD) {\n                return typeof v[key] === 'function';\n            }\n            return true;\n        }\n        return false;\n    };\n    ObservableNode.prototype.$is = function (check) {\n        if (check == node_1.IsCheck.ARRAY && Array.isArray(this._memoValue)) {\n            return true;\n        }\n        return false;\n    };\n    ObservableNode.prototype.$ownKeys = function () {\n        var v = this.$value;\n        return typeof v == 'object' ? Reflect.ownKeys(v) : [];\n    };\n    ObservableNode.prototype.$getOwnPropertyDescriptor = function (name) {\n        var v = this.$value;\n        return (typeof v == 'object') ? Reflect.getOwnPropertyDescriptor(v, name) : undefined;\n    };\n    ObservableNode.prototype._createEntry = function (value, key) {\n        return exports.proxify(value, new ObservableNode(value, this, key));\n    };\n    return ObservableNode;\n}(node_1.Node));\nexports.ObservableNode = ObservableNode;\nvar observable = function (initValue, uidFunc) {\n    var value = exports.isValueSet(initValue) ? initValue.$value : initValue;\n    return exports.proxify(value, new ObservableNode(value, null, null, uidFunc));\n};\nexports.observable = observable;\nvar reactive = function (initValue, uidFunc) {\n    var value = exports.isValueSet(initValue) ? initValue.$value : initValue;\n    return exports.proxify(value, new ObservableNode(value, null, null, uidFunc));\n};\nexports.reactive = reactive;\n// export const iterable = <T>(initValue: ObservableValueSet<T>|T, uidFunc: UidFunc) : ObservableValueSet<T>&T => {\n//     return observable(initValue, uidFunc)\n// }\nvar isObservable = function (v) {\n    return v != null && typeof v.$subscribe === 'function';\n    // if (v != null) {\n    //     if (v[__isProxy]) {\n    //         return '$subscribe' in v\n    //     }\n    //     else {\n    //         return v.$subscribe != null\n    //     }\n    // }\n    // return false\n    //    return v != null && (v as Observable<any>).$subscribe != undefined\n};\nexports.isObservable = isObservable;\nvar isValueSet = function (v) {\n    return v != null && typeof v.$at === 'function';\n    // if (v != null) {\n    //     if (v[__isProxy]) {\n    //         return '$at' in v\n    //     }\n    //     else {\n    //         return v.$at != null\n    //     }\n    // }\n    return false;\n};\nexports.isValueSet = isValueSet;\nvar isValueIterator = function (v) {\n    if (v != null) {\n        if (v[exports.__isProxy]) {\n            return 'next' in v;\n        }\n        else {\n            return v.next != null;\n        }\n    }\n    return false;\n};\nexports.isValueIterator = isValueIterator;\n// const ownProps: Set<string|number|symbol> = new Set(['$key', '$value', '$uid', '$source'])\n// console.log(Object.getOwnPropertyNames(new ProxyObservableNode()))\nexports.__isProxy = Symbol('__isProxy');\nexports.__isValue = Symbol('__isValue');\nvar proxify = function (obj, node) {\n    var proxy = new Proxy(node, {\n        get: function (target, name) {\n            // if (name == __isProxy) {\n            //     return true\n            // }\n            if (name == '_raw') {\n                debugger;\n            }\n            //            console.log(name, name in target)\n            // собственные свойства\n            if (name in target) {\n                var v = target[name];\n                if (v && typeof v === 'function') {\n                    return v.bind(target);\n                }\n                return v;\n            }\n            //             if (target.$is(IsCheck.ARRAY)) {\n            // //                console.log('array', target.$value, name)\n            //                 return (target.$value as any)[name]\n            //             }\n            if (target.$is(node_1.IsCheck.ARRAY)) {\n                if (name == 'splice') {\n                    var v_1 = target.$value;\n                    return function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        //                        debugger\n                        var out = v_1[name].apply(v_1, args);\n                        target.$value = v_1;\n                        return out;\n                    };\n                }\n            }\n            if (target.$has(name, node_1.HasCheck.METHOD)) {\n                var v = target.$value;\n                return v[name].bind(v); //proxy)\n            }\n            // if (!target.$has(name)) {\n            //     return undefined\n            // }\n            var entry = target.$at(name);\n            if (_AutoTerminal && entry.$isTerminal) {\n                //                console.log('terminal', name, target)\n                return entry.$value;\n            }\n            //            console.log('ENTRY')\n            return entry;\n        },\n        set: function (target, name, v) {\n            if (name in target) {\n                target[name] = v;\n            }\n            else {\n                target.$at(name).$value = v;\n            }\n            return true;\n        },\n        ownKeys: function (target) {\n            //            console.log('KEYS')\n            //            const v = target.$value\n            // if (v == null) {\n            //     return []\n            // }\n            return target.$ownKeys(); //.concat(Object.keys(target))\n        },\n        has: function (target, name) {\n            //            const v = target.$value\n            //            console.log('HAS', v, name)\n            // if (v == null) {\n            //     return false\n            // }\n            // if (typeof v === 'number') {\n            //     return name in Number.prototype\n            // }\n            // if (typeof v === 'boolean') {\n            //     return name in Boolean.prototype\n            // }\n            return Reflect.has(target, name) || target.$has(name); // Reflect.has(v as any, name)\n            //return target.$value != null && (name in target.$value)\n            //return true\n        },\n        getOwnPropertyDescriptor: function (target, name) {\n            //            console.log(name, target)\n            // if (target.$value == null) {\n            //     return {}\n            // }\n            var pd = Reflect.getOwnPropertyDescriptor(target, name) || target.$getOwnPropertyDescriptor(name); // Reflect.getOwnPropertyDescriptor(target.$value as any, name)\n            pd.configurable = true;\n            return pd;\n        },\n        apply: function (target, thisArg, args) {\n            return target.$call(thisArg, args);\n            // const f = (target.$value as any)\n            // f.$emit('before', args)\n            // return (target.$value as any).apply(thisArg, args)\n        }\n        // getPrototypeOf: (target) : object => {\n        //     console.log('get prototype of')\n        //     return Reflect.getPrototypeOf(target.$value as any)\n        //     // console.log('prototype of')\n        //     // if (typeof target.$value === 'number') {\n        //     //     return Number.prototype\n        //     // }\n        //     // return Object.getPrototypeOf(target.$value)\n        // }\n    });\n    return proxy;\n};\nexports.proxify = proxify;\n//# sourceMappingURL=observable.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PubSub = exports.spySubscriptions = void 0;\nvar bus_1 = require(\"./bus\");\n// Spies\nvar _SpySubscriptions = null;\nvar spySubscriptions = function (fn) {\n    var prevSub = _SpySubscriptions;\n    _SpySubscriptions = [];\n    fn();\n    var result = _SpySubscriptions;\n    _SpySubscriptions = prevSub;\n    return result;\n};\nexports.spySubscriptions = spySubscriptions;\nvar PubSub = /** @class */ (function (_super) {\n    __extends(PubSub, _super);\n    function PubSub(global) {\n        var _this = _super.call(this, global) || this;\n        _this._subscriptions = [];\n        return _this;\n    }\n    PubSub.prototype.$touch = function (subscriber) {\n        throw new Error(\"Method not implemented.\");\n    };\n    PubSub.prototype.$untouch = function () {\n        throw new Error(\"Method not implemented.\");\n    };\n    PubSub.prototype.$publish = function (next, prev, keys) {\n        throw new Error(\"Method not implemented.\");\n    };\n    PubSub.prototype.$subscribe = function (subscriber) {\n        // if (this._destroyed) {\n        //     console.error('Cannot subscribe to deleted value')\n        //     return null\n        // }\n        // проверяем, что такая подписка уже есть\n        for (var _i = 0, _a = this._subscriptions; _i < _a.length; _i++) {\n            var sub_1 = _a[_i];\n            if (sub_1.subscriber == subscriber || sub_1.subscriber.$publish == subscriber) {\n                return sub_1;\n            }\n        }\n        if (typeof subscriber === 'function') {\n            subscriber = {\n                $publish: subscriber\n            };\n        }\n        var sub = {\n            subscriber: subscriber,\n            observable: this\n        };\n        this._subscriptions.push(sub);\n        if (_SpySubscriptions) {\n            _SpySubscriptions.push(sub);\n        }\n        return sub;\n    };\n    PubSub.prototype.$unsubscribe = function (subscription) {\n        // if (this._destroyed) {\n        //     console.error('Cannot unsubscribe from deleted value')\n        //     return \n        // }\n        this._subscriptions = this._subscriptions.filter(function (sub) { return sub != subscription && sub.subscriber != subscription && sub.subscriber.$publish != subscription; });\n    };\n    Object.defineProperty(PubSub.prototype, \"$subscriptions\", {\n        // $touch(subscriber: Subscriber<T>): void {\n        //     //this._started = true\n        //     subscriber.$publish(this.$value, undefined, EMPTY)\n        // }\n        // $untouch () {\n        //     // TODO проверки при отсоединении\n        // }\n        get: function () {\n            return this._subscriptions;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return PubSub;\n}(bus_1.EventNode));\nexports.PubSub = PubSub;\n//# sourceMappingURL=pubsub.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isEventBus = exports.defaultUidFunc = exports.EMPTY = void 0;\nexports.EMPTY = Object.seal({});\n// let _SubscriptionSpy = []\n// export const spySubscriptions = (fn: Function) : Subscription[] => {\n//     // TODO\n//     return []\n// }\n// let _AutoSubscriber : Subscriber<any> = null\n// export const checkAutoSubscriber = () : Subscriber<any> => {\n//     return _AutoSubscriber\n// }\nvar defaultUidFunc = function (v) {\n    if (v == null) {\n        return undefined;\n    }\n    var uid = undefined;\n    if (typeof v == 'string' || typeof v == 'number' || typeof v == 'boolean' || typeof v == 'symbol') {\n        uid = String(v);\n    }\n    else if (v.id != null) {\n        uid = String(v.id);\n    }\n    else {\n        //        console.warn('Uid function should be defined', v)\n    }\n    if (uid == '[object Object]') {\n        console.warn('Uid should be a primitive value', uid, v);\n    }\n    return uid;\n};\nexports.defaultUidFunc = defaultUidFunc;\nvar isEventBus = function (v) {\n    return v != null && v.$hasEvent != undefined;\n};\nexports.isEventBus = isEventBus;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSimpleEngine = exports.SimpleEngine = void 0;\nvar core_1 = require(\"@chorda/core\");\nvar SimpleEngine = /** @class */ (function () {\n    function SimpleEngine() {\n        this.links = [];\n        this.tasks = [];\n        this.isScheduled = false;\n        this.subscriptions = [];\n        this.pipeTasks = [];\n    }\n    SimpleEngine.prototype.pipeTask = function (fn, arg, target) {\n        this.pipeTasks.push({ fn: fn, arg: arg, target: target });\n        !this.isScheduled && this.schedule();\n    };\n    SimpleEngine.prototype.chain = function (link) {\n        this.links.push(link);\n    };\n    SimpleEngine.prototype.scheduleTask = function (fn, arg, target) {\n        this.tasks.push({ fn: fn, arg: arg, target: target });\n        !this.isScheduled && this.schedule();\n    };\n    SimpleEngine.prototype.immediate = function () {\n    };\n    SimpleEngine.prototype.schedule = function () {\n        var _this = this;\n        if (!this.isScheduled) {\n            setTimeout(function () {\n                var t0 = performance.now();\n                var tasks = _this.tasks;\n                _this.tasks = [];\n                _this.isScheduled = false;\n                // TODO на этом этапе можно проводить анализ и перестроение порядка патчей\n                var deleted = 0;\n                tasks\n                    .forEach(function (task) {\n                    // фильтруем патчи удаленных компонентов\n                    if (task.target.state == core_1.State.Destroying || task.target.state == core_1.State.Destroyed) {\n                        deleted++;\n                        //                            console.warn('Ignoring target in destroying or destroyed state', task.target)\n                        return;\n                    }\n                    task.fn.call(task.target, task.arg);\n                });\n                // по мере исполнения пакета задач, могут накопиться другие задачи\n                // если новых задач нет, переходим к следующему движку по цепочке\n                if (_this.tasks.length == 0) {\n                    _this.subscriptions.forEach(function (f) { return f(); });\n                    _this.links.forEach(function (link) {\n                        var pipeTasks = _this.pipeTasks;\n                        _this.pipeTasks = [];\n                        pipeTasks.forEach(function (task) { return link.scheduleTask(task.fn, task.arg, task.target); });\n                        link.schedule();\n                    });\n                }\n                else if (!_this.isScheduled) {\n                    console.error('Not scheduled tasks found');\n                }\n                var t1 = performance.now();\n                console.log('tick', tasks.length, Math.round(t1 - t0), avgTimeInterval(t0, t1, tasks.length), deleted ? '-' + deleted : '');\n            });\n            this.isScheduled = true;\n        }\n    };\n    SimpleEngine.prototype.addPostEffect = function (fn) {\n        this.subscriptions.push(fn);\n        //        throw new Error(\"Method not implemented.\");\n    };\n    return SimpleEngine;\n}());\nexports.SimpleEngine = SimpleEngine;\nvar avgTimeInterval = function (t0, t1, total) {\n    return Number((Math.round(t1 - t0) / total).toFixed(5));\n};\nvar createSimpleEngine = function () {\n    return new SimpleEngine();\n};\nexports.createSimpleEngine = createSimpleEngine;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createAsyncPatcher = exports.PatchEngine = void 0;\nvar core_1 = require(\"@chorda/core\");\nvar destroyedTaskFilter = function (task) {\n    if (task.target && (task.target.state == core_1.State.Destroying || task.target.state == core_1.State.Destroyed)) {\n        //        deleted++\n        //      console.warn('Ignoring target in destroying or destroyed state', task.target)\n        return false;\n    }\n    return true;\n};\nvar avgTimeInterval = function (t0, t1, total) {\n    return Number((Math.round(t1 - t0) / total).toFixed(5));\n};\nvar PatchEngine = /** @class */ (function (_super) {\n    __extends(PatchEngine, _super);\n    function PatchEngine() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PatchEngine.prototype.process = function (tasks) {\n        var _this = this;\n        return tasks.filter(function (task) {\n            if (task.target && (task.target.state == core_1.State.Destroying || task.target.state == core_1.State.Destroyed)) {\n                //        deleted++\n                //      console.warn('Ignoring target in destroying or destroyed state', task.target)\n                return false;\n            }\n            return core_1.ownTaskFilter(_this)(task);\n        });\n        // return tasks\n        //     .filter(destroyedTaskFilter)\n        //     .filter(ownTaskFilter(this))\n    };\n    return PatchEngine;\n}(core_1.AsyncEngine));\nexports.PatchEngine = PatchEngine;\nvar createAsyncPatcher = function (name) {\n    return new PatchEngine(name);\n};\nexports.createAsyncPatcher = createAsyncPatcher;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./engine\"), exports);\n__exportStar(require(\"./engine2\"), exports);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"sourceRoot":""}